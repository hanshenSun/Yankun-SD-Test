"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sphere = void 0;
const gl_matrix_1 = require("gl-matrix");
class Sphere {
    constructor(_center = gl_matrix_1.vec3.create(), _radius = 0) {
        this._center = _center;
        this._radius = _radius;
    }
    get center() {
        return this._center;
    }
    set center(value) {
        this._center = value;
    }
    get radius() {
        return this._radius;
    }
    set radius(value) {
        this._radius = value;
    }
    applyMatrix(matrix) {
        this._center = gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), this._center, matrix);
        const scaleXSq = matrix[0] * matrix[0] + matrix[1] * matrix[1] + matrix[2] * matrix[2];
        const scaleYSq = matrix[4] * matrix[4] + matrix[5] * matrix[5] + matrix[6] * matrix[6];
        const scaleZSq = matrix[8] * matrix[8] + matrix[9] * matrix[9] + matrix[10] * matrix[10];
        const maxScaleOnAxis = Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        this.radius = this.radius * maxScaleOnAxis;
        return this;
    }
    clone() {
        return new Sphere(gl_matrix_1.vec3.clone(this._center), this._radius);
    }
    containsPoint(point) {
        return (gl_matrix_1.vec3.squaredDistance(point, this.center) <= (this.radius * this.radius));
    }
    clampPoint(point) {
        return point;
    }
    setFromBox(box) {
        gl_matrix_1.vec3.add(this.center, box.min, box.max);
        gl_matrix_1.vec3.scale(this.center, this.center, 0.5);
        this.radius = gl_matrix_1.vec3.dist(box.min, box.max) * 0.5;
        return this;
    }
}
exports.Sphere = Sphere;
//# sourceMappingURL=Sphere.js.map