"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Box = void 0;
const gl_matrix_1 = require("gl-matrix");
const Sphere_1 = require("./Sphere");
class Box {
    constructor(_min = gl_matrix_1.vec3.fromValues(Infinity, Infinity, Infinity), _max = gl_matrix_1.vec3.fromValues(-Infinity, -Infinity, -Infinity)) {
        this._min = _min;
        this._max = _max;
        this._boundingSphere = new Sphere_1.Sphere();
        this._boundingSphereState = {
            min: gl_matrix_1.vec3.create(), max: gl_matrix_1.vec3.create()
        };
    }
    intersect(origin, direction) {
        let tmin, tmax, txmin, txmax, tymin, tymax, tzmin, tzmax;
        const invdirx = 1 / direction[0], invdiry = 1 / direction[1], invdirz = 1 / direction[2];
        txmin = invdirx >= 0 ? (this.min[0] - origin[0]) * invdirx : (this.max[0] - origin[0]) * invdirx;
        txmax = invdirx >= 0 ? (this.max[0] - origin[0]) * invdirx : (this.min[0] - origin[0]) * invdirx;
        tmin = txmin;
        tmax = txmax;
        tymin = invdiry >= 0 ? (this.min[1] - origin[1]) * invdiry : (this.max[1] - origin[1]) * invdiry;
        tymax = invdiry >= 0 ? (this.max[1] - origin[1]) * invdiry : (this.min[1] - origin[1]) * invdiry;
        if ((tmin > tymax) || (tymin > tmax))
            return null;
        if (tymin > tmin || tmin !== tmin)
            tmin = tymin;
        if (tymax < tmax || tmax !== tmax)
            tmax = tymax;
        tzmin = invdirz >= 0 ? (this.min[2] - origin[2]) * invdirz : (this.max[2] - origin[2]) * invdirz;
        tzmax = invdirz >= 0 ? (this.max[2] - origin[2]) * invdirz : (this.min[2] - origin[2]) * invdirz;
        if ((tmin > tzmax) || (tzmin > tmax))
            return null;
        if (tzmin > tmin || tmin !== tmin)
            tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax)
            tmax = tzmax;
        if (tmax < 0)
            return null;
        return tmin >= 0 ? tmin : tmax;
    }
    ;
    get boundingSphere() {
        if (!(this._boundingSphereState.min[0] === this.min[0] && this._boundingSphereState.min[1] === this.min[1] && this._boundingSphereState.min[2] === this.min[2] &&
            this._boundingSphereState.max[0] === this.max[0] && this._boundingSphereState.max[1] === this.max[1] && this._boundingSphereState.max[2] === this.max[2])) {
            this._boundingSphere.setFromBox(this);
            this._boundingSphereState = {
                min: gl_matrix_1.vec3.clone(this.min),
                max: gl_matrix_1.vec3.clone(this.max)
            };
        }
        return this._boundingSphere;
    }
    get max() {
        return this._max;
    }
    set max(value) {
        this._max = value;
    }
    get min() {
        return this._min;
    }
    set min(value) {
        this._min = value;
    }
    applyMatrix(matrix) {
        const points = [];
        points.push(gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this.min[0], this.min[1], this.min[2]), matrix));
        points.push(gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this.min[0], this.min[1], this.max[2]), matrix));
        points.push(gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this.min[0], this.max[1], this.min[2]), matrix));
        points.push(gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this.min[0], this.max[1], this.max[2]), matrix));
        points.push(gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this.max[0], this.min[1], this.min[2]), matrix));
        points.push(gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this.max[0], this.min[1], this.max[2]), matrix));
        points.push(gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this.max[0], this.max[1], this.min[2]), matrix));
        points.push(gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(this.max[0], this.max[1], this.max[2]), matrix));
        this.min = gl_matrix_1.vec3.fromValues(Infinity, Infinity, Infinity);
        this.max = gl_matrix_1.vec3.fromValues(-Infinity, -Infinity, -Infinity);
        for (let i = 0, il = points.length; i < il; i++) {
            this.min = gl_matrix_1.vec3.fromValues(Math.min(this.min[0], points[i][0]), Math.min(this.min[1], points[i][1]), Math.min(this.min[2], points[i][2]));
            this.max = gl_matrix_1.vec3.fromValues(Math.max(this.max[0], points[i][0]), Math.max(this.max[1], points[i][1]), Math.max(this.max[2], points[i][2]));
        }
        return this;
    }
    clone() {
        return new Box(gl_matrix_1.vec3.clone(this.min), gl_matrix_1.vec3.clone(this.max));
    }
    containsPoint(point) {
        return point[0] < this.min[0] || point[0] > this.max[0] ||
            point[1] < this.min[1] || point[1] > this.max[1] ||
            point[2] < this.min[2] || point[2] > this.max[2] ? false : true;
    }
    clampPoint(point) {
        return point;
    }
    setFromAttributeArray(array) {
        let minX = Infinity, minY = Infinity, minZ = Infinity;
        let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
        for (let i = 0; i < array.length; i += 3) {
            const x = array[i];
            const y = array[i + 1];
            const z = array[i + 2];
            if (x < minX)
                minX = x;
            if (y < minY)
                minY = y;
            if (z < minZ)
                minZ = z;
            if (x > maxX)
                maxX = x;
            if (y > maxY)
                maxY = y;
            if (z > maxZ)
                maxZ = z;
        }
        this.min = gl_matrix_1.vec3.fromValues(minX, minY, minZ);
        this.max = gl_matrix_1.vec3.fromValues(maxX, maxY, maxZ);
        return this;
    }
    union(box) {
        if (box.min[0] < this.min[0])
            this.min[0] = box.min[0];
        if (box.min[1] < this.min[1])
            this.min[1] = box.min[1];
        if (box.min[2] < this.min[2])
            this.min[2] = box.min[2];
        if (box.max[0] > this.max[0])
            this.max[0] = box.max[0];
        if (box.max[1] > this.max[1])
            this.max[1] = box.max[1];
        if (box.max[2] > this.max[2])
            this.max[2] = box.max[2];
        return this;
    }
    isEmpty() {
        return this.min[0] === Infinity && this.min[1] === Infinity && this.min[2] === Infinity &&
            this.max[0] === -Infinity && this.max[1] === -Infinity && this.max[2] === -Infinity;
    }
}
exports.Box = Box;
//# sourceMappingURL=Box.js.map