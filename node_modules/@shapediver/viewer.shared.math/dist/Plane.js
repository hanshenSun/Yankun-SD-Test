"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Plane = void 0;
const gl_matrix_1 = require("gl-matrix");
class Plane {
    constructor(_normal = gl_matrix_1.vec3.fromValues(1, 0, 0), _constant = 0) {
        this._normal = _normal;
        this._constant = _constant;
    }
    get constant() {
        return this._constant;
    }
    set constant(value) {
        this._constant = value;
    }
    get normal() {
        return this._normal;
    }
    set normal(value) {
        this._normal = value;
    }
    applyMatrix(matrix) {
        const normalMatrix = gl_matrix_1.mat3.transpose(gl_matrix_1.mat3.create(), gl_matrix_1.mat3.invert(gl_matrix_1.mat3.create(), gl_matrix_1.mat3.fromMat4(gl_matrix_1.mat3.create(), matrix)));
        const p = gl_matrix_1.vec3.transformMat4(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.clone(this.normal), gl_matrix_1.vec3.fromValues(this._constant, this._constant, this._constant)), matrix);
        this._normal = gl_matrix_1.vec3.normalize(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.transformMat3(gl_matrix_1.vec3.create(), this._normal, normalMatrix));
        this.constant = -gl_matrix_1.vec3.dot(p, this._normal);
        return this;
    }
    clampPoint(point) {
        const d = -this.distanceToPoint(point);
        return gl_matrix_1.vec3.add(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.multiply(gl_matrix_1.vec3.create(), this.normal, gl_matrix_1.vec3.fromValues(d, d, d)), point);
    }
    clone() {
        return new Plane(this._normal, this._constant);
    }
    containsPoint(point) {
        return this.distanceToPoint(point) === 0;
    }
    distanceToPoint(point) {
        return gl_matrix_1.vec3.dot(this.normal, point) + this.constant;
    }
    intersect(origin, direction) {
        const denominator = gl_matrix_1.vec3.dot(this.normal, direction);
        if (denominator === 0) {
            if (this.distanceToPoint(origin) === 0)
                return 0;
            return null;
        }
        const t = -(gl_matrix_1.vec3.dot(origin, this.normal) + this.constant) / denominator;
        if (t < 0)
            return null;
        return t;
    }
    setFromNormalAndCoplanarPoint(normal, point) {
        gl_matrix_1.vec3.copy(this.normal, normal);
        this.constant = -gl_matrix_1.vec3.dot(point, this.normal);
        return this;
    }
}
exports.Plane = Plane;
//# sourceMappingURL=Plane.js.map