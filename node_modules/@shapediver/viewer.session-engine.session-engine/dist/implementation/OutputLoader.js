"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OutputLoader = void 0;
const tsyringe_1 = require("tsyringe");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const viewer_data_engine_data_engine_1 = require("@shapediver/viewer.data-engine.data-engine");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const OutputDelayException_1 = require("./OutputDelayException");
const SessionTreeNode_1 = require("./SessionTreeNode");
const SessionOutputData_1 = require("./SessionOutputData");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
class OutputLoader {
    constructor() {
        this._dataEngine = tsyringe_1.container.resolve(viewer_data_engine_data_engine_1.DataEngine);
        this._performanceEvaluator = tsyringe_1.container.resolve(viewer_shared_services_1.PerformanceEvaluator);
        this._lastOutputNodes = {};
    }
    loadOutputs(session, outputs) {
        return __awaiter(this, void 0, void 0, function* () {
            this._performanceEvaluator.startSection('outputLoading');
            const node = new SessionTreeNode_1.SessionTreeNode(session.name);
            let currentNodes = {};
            let promises = [];
            let promisesNodes = [];
            let maxDelay = 0;
            for (let outputID in outputs) {
                currentNodes[outputID] = {};
                if (!this._lastOutputNodes[outputID])
                    this._lastOutputNodes[outputID] = {};
                if (outputs[outputID].delay) {
                    maxDelay = Math.max(maxDelay, outputs[outputID].delay);
                }
                else if (!this._lastOutputNodes[outputID][outputs[outputID].version]) {
                    currentNodes[outputID][outputs[outputID].version] = new SessionTreeNode_1.SessionTreeNode(outputID);
                    currentNodes[outputID][outputs[outputID].version].data.push(new SessionOutputData_1.SessionOutputData(outputs[outputID]));
                    if (outputs[outputID].content) {
                        for (let i = 0, len = outputs[outputID].content.length; i < len; i++) {
                            promises.push(this._dataEngine.loadContent(outputs[outputID].content[i]));
                            promisesNodes.push(currentNodes[outputID][outputs[outputID].version]);
                        }
                    }
                }
                else {
                    currentNodes[outputID][outputs[outputID].version] = this._lastOutputNodes[outputID][outputs[outputID].version];
                }
            }
            if (maxDelay)
                throw new OutputDelayException_1.OutputDelayException(maxDelay);
            yield Promise.all(promises);
            for (let i = 0; i < promises.length; i++)
                promisesNodes[i].addChild(yield promises[i]);
            for (let outputID in outputs) {
                node.addChild(currentNodes[outputID][outputs[outputID].version]);
            }
            for (let outputID in outputs) {
                this._lastOutputNodes[outputID] = {};
                this._lastOutputNodes[outputID][outputs[outputID].version] = currentNodes[outputID][outputs[outputID].version];
            }
            for (let outputID in outputs) {
                if (currentNodes[outputID][outputs[outputID].version].children.length > 1) {
                    for (let i = 0, len = outputs[outputID].content.length; i < len; i++) {
                        if (outputs[outputID].content[i].format === 'sdtf') {
                            this.mergeContentNodes(currentNodes[outputID][outputs[outputID].version]);
                            break;
                        }
                    }
                }
            }
            this.assignMaterials(node);
            this._performanceEvaluator.endSection('outputLoading');
            return node;
        });
    }
    mergeContentNodes(node) {
        if (!(node.children.length > 1))
            return;
        const children = [];
        while (node.children.length > 0) {
            children.push(node.children[0]);
            node.removeChild(node.children[0]);
        }
        const mergeNodes = (node1, node2) => {
            for (let i = 0; i < node1.data.length; i++)
                node2.data.push(node1.data[i]);
            for (let i = 0; i < node1.children.length; i++) {
                let childNode;
                for (let j = 0; j < node2.children.length; j++) {
                    if (node1.children[i].name === node2.children[j].name) {
                        childNode = node2.children[j];
                        break;
                    }
                }
                if (!childNode) {
                    childNode = new viewer_shared_node_tree_1.TreeNode(node1.children[i].name);
                    node2.addChild(childNode);
                }
                mergeNodes(node1.children[i], childNode);
            }
        };
        const newChild = new viewer_shared_node_tree_1.TreeNode('content_array');
        node.addChild(newChild);
        for (let i = 0; i < children.length; i++)
            mergeNodes(children[i], newChild);
    }
    assignMaterials(node) {
        const addMaterialToGeometry = (node, material) => {
            for (let i = 0; i < node.data.length; i++)
                if (node.data[i] instanceof viewer_shared_types_1.GeometryData)
                    node.data[i].primitive.material = material;
            for (let i = 0; i < node.children.length; i++) {
                const child = node.children[i];
                if (child)
                    addMaterialToGeometry(child, material);
            }
        };
        const getMaterialData = (node, materials = []) => {
            for (let k = 0; k < node.data.length; k++)
                if (node.data[k] instanceof viewer_shared_types_1.MaterialData)
                    materials.push(node.data[k]);
            for (let k = 0; k < node.children.length; k++) {
                const child = node.children[k];
                if (!child)
                    continue;
                materials.push(...getMaterialData(child));
            }
            return materials;
        };
        const getGeometryData = (node, geometries = []) => {
            for (let k = 0; k < node.data.length; k++)
                if (node.data[k] instanceof viewer_shared_types_1.GeometryData)
                    geometries.push(node.data[k]);
            for (let k = 0; k < node.children.length; k++) {
                const child = node.children[k];
                if (!child)
                    continue;
                geometries.push(...getGeometryData(child));
            }
            return geometries;
        };
        for (let m = 0; m < node.children.length; m++) {
            const outputNode = node.children[m];
            if (!outputNode)
                continue;
            for (let i = 0; i < outputNode.data.length; i++) {
                if (!(outputNode.data[i] instanceof SessionOutputData_1.SessionOutputData))
                    continue;
                const sessionOutputData = outputNode.data[i];
                if (sessionOutputData.sessionOutput.material) {
                    let materials = [];
                    for (let n = 0; n < node.children.length; n++) {
                        const materialNode = node.children[n];
                        if (!materialNode)
                            continue;
                        if (materialNode.name === sessionOutputData.sessionOutput.material)
                            materials = getMaterialData(materialNode);
                    }
                    const geometries = getGeometryData(outputNode);
                    if (materials.length === geometries.length) {
                        for (let n = 0; n < geometries.length; n++)
                            geometries[n].primitive.material = materials[n];
                    }
                    else {
                        if (materials.length >= 1)
                            for (let n = 0; n < geometries.length; n++)
                                geometries[n].primitive.material = materials[0];
                    }
                }
                else {
                    const sessionOutputContent = sessionOutputData.sessionOutput.content;
                    if (sessionOutputContent === undefined)
                        continue;
                    const materials = getMaterialData(outputNode);
                    const geometries = getGeometryData(outputNode);
                    if (materials.length === geometries.length) {
                        for (let n = 0; n < geometries.length; n++)
                            geometries[n].primitive.material = materials[n];
                    }
                }
            }
        }
    }
}
exports.OutputLoader = OutputLoader;
//# sourceMappingURL=OutputLoader.js.map