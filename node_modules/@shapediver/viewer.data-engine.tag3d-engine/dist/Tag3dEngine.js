"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tag3dEngine = void 0;
const THREE = __importStar(require("three"));
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const tsyringe_1 = require("tsyringe");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
var JUSTIFICATION;
(function (JUSTIFICATION) {
    JUSTIFICATION["TOP_LEFT"] = "TL";
    JUSTIFICATION["TOP_CENTER"] = "TC";
    JUSTIFICATION["TOP_RIGHT"] = "TR";
    JUSTIFICATION["MIDDLE_LEFT"] = "ML";
    JUSTIFICATION["MIDDLE_CENTER"] = "MC";
    JUSTIFICATION["MIDDLE_RIGHT"] = "MR";
    JUSTIFICATION["BOTTOM_LEFT"] = "BL";
    JUSTIFICATION["BOTTOM_CENTER"] = "BC";
    JUSTIFICATION["BOTTOM_RIGHT"] = "BR";
})(JUSTIFICATION || (JUSTIFICATION = {}));
let Tag3dEngine = class Tag3dEngine {
    constructor() {
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
        this._converter = tsyringe_1.container.resolve(viewer_shared_services_1.Converter);
        this._httpClient = tsyringe_1.container.resolve(viewer_shared_services_1.HttpClient);
        this._stateEngine = tsyringe_1.container.resolve(viewer_shared_services_1.StateEngine);
        this._httpClient.get('https://viewer.shapediver.com/graphik_regular.typeface.json').then((fontJson) => {
            this._font = new THREE.Font(fontJson.data);
            this._stateEngine.fontLoaded.resolve(true);
        });
    }
    loadContent(content) {
        return __awaiter(this, void 0, void 0, function* () {
            const node = new viewer_shared_node_tree_1.TreeNode('tag3d');
            if (this._stateEngine.fontLoaded.resolved === false)
                yield this._stateEngine.fontLoaded;
            if (!content) {
                this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, new viewer_shared_services_1.SDError('Tag3dEngine.loadContent: Invalid content was provided to tag3d engine.'));
                return node;
            }
            if (content.data && Array.isArray(content.data)) {
                for (let i = 0; i < content.data.length; i++) {
                    const tag3dInfo = content.data[i];
                    tag3dInfo.size = tag3dInfo.size ? +tag3dInfo.size : 1;
                    tag3dInfo.text = tag3dInfo.text || '';
                    tag3dInfo.color = this._converter.toColor(tag3dInfo.color);
                    const tagLines = tag3dInfo.text.split(/\r\n|\r|\n/g);
                    let lineArray = [];
                    for (let lineIndex = 0; lineIndex < tagLines.length; ++lineIndex) {
                        let tag = new THREE.TextBufferGeometry(tagLines[lineIndex], { size: tag3dInfo.size, height: tag3dInfo.size / 10, font: this._font });
                        lineArray.push(tag);
                    }
                    let parentObject = new THREE.Object3D();
                    for (let line of lineArray) {
                        parentObject.add(new THREE.Mesh(line, new THREE.MeshPhongMaterial()));
                    }
                    let bb, extentsX, extentsY, lineHeight = 0;
                    {
                        lineHeight = 0;
                        for (let child of parentObject.children) {
                            bb = new THREE.Box3().setFromObject(child);
                            extentsY = bb.max.y - bb.min.y;
                            lineHeight = Math.max(lineHeight, extentsY);
                        }
                    }
                    lineHeight *= 1.15;
                    lineArray.forEach((line, i) => {
                        line.translate(0, (-i - 1) * lineHeight, 0);
                    });
                    bb = new THREE.Box3().setFromObject(parentObject);
                    extentsX = bb.max.x - bb.min.x;
                    extentsY = bb.max.y - bb.min.y;
                    var tagJustTranslation = new THREE.Vector3(0, 0, 0);
                    switch (tag3dInfo.justification) {
                        case 'TL':
                            break;
                        case 'TC':
                            tagJustTranslation.x = -extentsX * 0.5;
                            break;
                        case 'TR':
                            tagJustTranslation.x = -extentsX;
                            break;
                        case 'ML':
                            tagJustTranslation.y = extentsY * 0.5;
                            break;
                        case 'MC':
                            tagJustTranslation.x = -extentsX * 0.5;
                            tagJustTranslation.y = extentsY * 0.5;
                            break;
                        case 'MR':
                            tagJustTranslation.x = -extentsX;
                            tagJustTranslation.y = extentsY * 0.5;
                            break;
                        case 'BL':
                            tagJustTranslation.y = extentsY;
                            break;
                        case 'BC':
                            tagJustTranslation.x = -extentsX * 0.5;
                            tagJustTranslation.y = extentsY;
                            break;
                        case 'BR':
                            tagJustTranslation.x = -extentsX;
                            tagJustTranslation.y = extentsY;
                            break;
                    }
                    for (let line of lineArray) {
                        line.translate(tagJustTranslation.x, tagJustTranslation.y, tagJustTranslation.z);
                    }
                    if (tag3dInfo.location.hasOwnProperty('xAxis')) {
                        var rotMatrix = new THREE.Matrix4();
                        rotMatrix.set(tag3dInfo.location.xAxis.X, tag3dInfo.location.yAxis.X, tag3dInfo.location.normal.X, 0, tag3dInfo.location.xAxis.Y, tag3dInfo.location.yAxis.Y, tag3dInfo.location.normal.Y, 0, tag3dInfo.location.xAxis.Z, tag3dInfo.location.yAxis.Z, tag3dInfo.location.normal.Z, 0, 0, 0, 0, 1);
                        for (let line of lineArray) {
                            line.applyMatrix4(rotMatrix);
                            line.translate(tag3dInfo.location.origin.X, tag3dInfo.location.origin.Y, tag3dInfo.location.origin.Z);
                        }
                    }
                    for (let line of lineArray) {
                        const attributes = {};
                        for (let attribute in line.attributes) {
                            attributes[attribute.toUpperCase()] = new viewer_shared_types_1.AttributeData(line.attributes[attribute].array, line.attributes[attribute].itemSize, 0, 0, 0, false, line.attributes[attribute].array.length);
                        }
                        node.data.push(new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, 4, null, new viewer_shared_types_1.MaterialData({ color: tag3dInfo.color }))));
                    }
                }
            }
            else {
                this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, new viewer_shared_services_1.SDError('Tag3dEngine.loadContent: No tag3d data was provided to tag3d engine.'));
            }
            return node;
        });
    }
};
Tag3dEngine = __decorate([
    tsyringe_1.singleton(),
    __metadata("design:paramtypes", [])
], Tag3dEngine);
exports.Tag3dEngine = Tag3dEngine;
//# sourceMappingURL=Tag3dEngine.js.map