"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InputValidator = void 0;
const tsyringe_1 = require("tsyringe");
const Logger_1 = require("../logger/Logger");
const SDError_1 = require("../logger/SDError");
const TypeChecker_1 = require("../type-check/TypeChecker");
let InputValidator = class InputValidator {
    constructor() {
        this._logger = tsyringe_1.container.resolve(Logger_1.Logger);
        this._typeChecker = tsyringe_1.container.resolve(TypeChecker_1.TypeChecker);
    }
    validateAndError(topic, scope, value, type, defined = true, enumValues = []) {
        const res = this.validate(value, type, defined, enumValues);
        if (res)
            return;
        const error = new SDError_1.SDError(`${scope}: Input could not be validated. ${value} is not of type ${type}.${defined === false ? ' (Can also be undefined)' : ''}`);
        this._logger.warn(topic, error.message);
        throw error;
    }
    validate(value, stringLiteral, defined = true, enumValues = []) {
        if (defined === false && typeof value === 'undefined')
            return true;
        switch (stringLiteral) {
            case 'string':
                if (this._typeChecker.isTypeOf(value, 'string'))
                    return true;
                break;
            case 'boolean':
                if (this._typeChecker.isTypeOf(value, 'boolean'))
                    return true;
                break;
            case 'function':
                if (this._typeChecker.isTypeOf(value, 'function'))
                    return true;
                break;
            case 'number':
                if (this._typeChecker.isTypeOf(value, 'number') && !isNaN(value))
                    return true;
                break;
            case 'factor':
                if (this._typeChecker.isTypeOf(value, 'number') && value >= 0 && value <= 1)
                    return true;
                break;
            case 'positive':
                if (this._typeChecker.isTypeOf(value, 'number') && value >= 0)
                    return true;
                break;
            case 'HTMLCanvasElement':
                if (this._typeChecker.isHTMLCanvasElement(value))
                    return true;
                break;
            case 'enum':
                if (this._typeChecker.isTypeOf(value, 'string') && enumValues.includes(value))
                    return true;
                break;
            case 'vec3':
                if (value.constructor === Float32Array)
                    value = Array.from(value);
                if (Array.isArray(value) && this._typeChecker.isTypeOf(value[0], 'number') && this._typeChecker.isTypeOf(value[1], 'number') && this._typeChecker.isTypeOf(value[2], 'number'))
                    return true;
                break;
            case 'cubeMap':
                if (Array.isArray(value) && value.length === 6 && this._typeChecker.isTypeOf(value[0], 'string') && this._typeChecker.isTypeOf(value[1], 'string') && this._typeChecker.isTypeOf(value[2], 'string') && this._typeChecker.isTypeOf(value[3], 'string') && this._typeChecker.isTypeOf(value[4], 'string') && this._typeChecker.isTypeOf(value[5], 'string'))
                    return true;
                if (this._typeChecker.isTypeOf(value, 'string'))
                    return true;
                break;
            case 'stringArray':
                if (Array.isArray(value)) {
                    let check = true;
                    for (let i = 0; i < value.length; i++)
                        if (typeof value[i] !== 'string')
                            check = false;
                    if (check === true)
                        return true;
                }
                break;
            case 'object':
                if (this._typeChecker.isTypeOf(value, 'object'))
                    return true;
                break;
            case 'file':
                if (this._typeChecker.isTypeOf(value, 'string') || value instanceof File || value instanceof Blob)
                    return true;
                break;
            case 'color':
                if (this._typeChecker.isTypeOf(value, 'string') || (Array.isArray(value) && this._typeChecker.isTypeOf(value[0], 'number') && this._typeChecker.isTypeOf(value[1], 'number') && this._typeChecker.isTypeOf(value[2], 'number')) || this._typeChecker.isTypeOf(value, 'number'))
                    return true;
                break;
            case 'mat4':
                if (value.constructor === Float32Array)
                    value = Array.from(value);
                if (Array.isArray(value) && this._typeChecker.isTypeOf(value[0], 'number') && this._typeChecker.isTypeOf(value[1], 'number') && this._typeChecker.isTypeOf(value[2], 'number') && this._typeChecker.isTypeOf(value[3], 'number')
                    && this._typeChecker.isTypeOf(value[4], 'number') && this._typeChecker.isTypeOf(value[5], 'number') && this._typeChecker.isTypeOf(value[6], 'number') && this._typeChecker.isTypeOf(value[7], 'number')
                    && this._typeChecker.isTypeOf(value[8], 'number') && this._typeChecker.isTypeOf(value[9], 'number') && this._typeChecker.isTypeOf(value[10], 'number') && this._typeChecker.isTypeOf(value[11], 'number')
                    && this._typeChecker.isTypeOf(value[12], 'number') && this._typeChecker.isTypeOf(value[13], 'number') && this._typeChecker.isTypeOf(value[14], 'number') && this._typeChecker.isTypeOf(value[15], 'number'))
                    return true;
                break;
            default:
                return false;
        }
        return false;
    }
};
InputValidator = __decorate([
    tsyringe_1.singleton()
], InputValidator);
exports.InputValidator = InputValidator;
//# sourceMappingURL=InputValidator.js.map