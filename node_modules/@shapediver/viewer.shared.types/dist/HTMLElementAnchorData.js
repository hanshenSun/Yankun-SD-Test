"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _HTMLElementAnchorData_htmlElement, _HTMLElementAnchorData_viewerHtmlElement, _HTMLElementAnchorData_data, _HTMLElementAnchorData_format, _HTMLElementAnchorData_hideable, _HTMLElementAnchorData_intersectionTarget, _HTMLElementAnchorData_location, _HTMLElementAnchorData_viewers;
Object.defineProperty(exports, "__esModule", { value: true });
exports.HTMLElementAnchorData = void 0;
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
class HTMLElementAnchorData extends viewer_shared_node_tree_1.AbstractTreeNodeData {
    constructor(location, data, format, hideable = true, viewers = [], intersectionTarget, id) {
        super(id);
        _HTMLElementAnchorData_htmlElement.set(this, void 0);
        _HTMLElementAnchorData_viewerHtmlElement.set(this, {});
        _HTMLElementAnchorData_data.set(this, void 0);
        _HTMLElementAnchorData_format.set(this, void 0);
        _HTMLElementAnchorData_hideable.set(this, true);
        _HTMLElementAnchorData_intersectionTarget.set(this, void 0);
        _HTMLElementAnchorData_location.set(this, void 0);
        _HTMLElementAnchorData_viewers.set(this, []);
        __classPrivateFieldSet(this, _HTMLElementAnchorData_location, location, "f");
        __classPrivateFieldSet(this, _HTMLElementAnchorData_data, data, "f");
        __classPrivateFieldSet(this, _HTMLElementAnchorData_format, format, "f");
        __classPrivateFieldSet(this, _HTMLElementAnchorData_hideable, hideable, "f");
        __classPrivateFieldSet(this, _HTMLElementAnchorData_viewers, viewers, "f");
        __classPrivateFieldSet(this, _HTMLElementAnchorData_intersectionTarget, intersectionTarget, "f");
        __classPrivateFieldSet(this, _HTMLElementAnchorData_htmlElement, document.createElement('div'), "f");
        __classPrivateFieldGet(this, _HTMLElementAnchorData_htmlElement, "f").style.display = 'none';
        __classPrivateFieldGet(this, _HTMLElementAnchorData_htmlElement, "f").style.userSelect = 'none';
        __classPrivateFieldGet(this, _HTMLElementAnchorData_htmlElement, "f").style.cursor = 'default';
        __classPrivateFieldGet(this, _HTMLElementAnchorData_htmlElement, "f").style.pointerEvents = 'none';
        __classPrivateFieldGet(this, _HTMLElementAnchorData_htmlElement, "f").style.position = 'absolute';
        __classPrivateFieldGet(this, _HTMLElementAnchorData_htmlElement, "f").style.fontFamily = '"Helvetica Neue", Helvetica, Arial, sans-serif';
        __classPrivateFieldGet(this, _HTMLElementAnchorData_htmlElement, "f").style.whiteSpace = 'nowrap';
        __classPrivateFieldGet(this, _HTMLElementAnchorData_htmlElement, "f").style.textOverflow = 'clip';
        __classPrivateFieldGet(this, _HTMLElementAnchorData_htmlElement, "f").classList.add('shapediver-domElement');
        if (this.format === 'text')
            this.createTextElement(this.data);
        if (this.format === 'image')
            this.createImageElement(this.data);
    }
    get data() {
        return __classPrivateFieldGet(this, _HTMLElementAnchorData_data, "f");
    }
    set data(value) {
        __classPrivateFieldSet(this, _HTMLElementAnchorData_data, value, "f");
    }
    get format() {
        return __classPrivateFieldGet(this, _HTMLElementAnchorData_format, "f");
    }
    set format(value) {
        __classPrivateFieldSet(this, _HTMLElementAnchorData_format, value, "f");
    }
    get hideable() {
        return __classPrivateFieldGet(this, _HTMLElementAnchorData_hideable, "f");
    }
    set hideable(value) {
        __classPrivateFieldSet(this, _HTMLElementAnchorData_hideable, value, "f");
    }
    get intersectionTarget() {
        return __classPrivateFieldGet(this, _HTMLElementAnchorData_intersectionTarget, "f");
    }
    set intersectionTarget(value) {
        __classPrivateFieldSet(this, _HTMLElementAnchorData_intersectionTarget, value, "f");
    }
    get location() {
        return __classPrivateFieldGet(this, _HTMLElementAnchorData_location, "f");
    }
    set location(value) {
        __classPrivateFieldSet(this, _HTMLElementAnchorData_location, value, "f");
    }
    get viewers() {
        return __classPrivateFieldGet(this, _HTMLElementAnchorData_viewers, "f");
    }
    set viewers(value) {
        __classPrivateFieldSet(this, _HTMLElementAnchorData_viewers, value, "f");
    }
    clone() {
        return new HTMLElementAnchorData(this.location, this.data, this.format, this.hideable, this.viewers, this.intersectionTarget, this.id);
    }
    createViewerHtmlElement(viewer) {
        if (__classPrivateFieldGet(this, _HTMLElementAnchorData_viewerHtmlElement, "f")[viewer])
            return __classPrivateFieldGet(this, _HTMLElementAnchorData_viewerHtmlElement, "f")[viewer];
        if (this.viewers.includes(viewer) || this.viewers.length === 0) {
            __classPrivateFieldGet(this, _HTMLElementAnchorData_viewerHtmlElement, "f")[viewer] = __classPrivateFieldGet(this, _HTMLElementAnchorData_htmlElement, "f").cloneNode(true);
            return __classPrivateFieldGet(this, _HTMLElementAnchorData_viewerHtmlElement, "f")[viewer];
        }
        return null;
    }
    getViewerHtmlElement(viewer) {
        if (__classPrivateFieldGet(this, _HTMLElementAnchorData_viewerHtmlElement, "f")[viewer])
            return __classPrivateFieldGet(this, _HTMLElementAnchorData_viewerHtmlElement, "f")[viewer];
        return null;
    }
    update() {
    }
    createImageElement(data) {
        const img = document.createElement('img');
        __classPrivateFieldGet(this, _HTMLElementAnchorData_htmlElement, "f").appendChild(img);
        img.src = data.src;
        if (data.height)
            img.height = data.height;
        if (data.width)
            img.width = data.width;
        if (data.alt)
            img.alt = data.alt;
    }
    createTextElement(data) {
        var _a;
        const span = document.createElement('span');
        span.style.color = (_a = data.color) === null || _a === void 0 ? void 0 : _a.toString();
        span.innerHTML = data.text;
        span.style.display = 'block';
        span.style.textOverflow = 'clip';
        span.style.overflow = 'hidden';
        __classPrivateFieldGet(this, _HTMLElementAnchorData_htmlElement, "f").appendChild(span);
        if (data.textAlign && (data.textAlign === 'right' || data.textAlign === 'center')) {
            span.style.textAlign = data.textAlign;
        }
        else {
            span.style.textAlign = 'left';
        }
    }
}
exports.HTMLElementAnchorData = HTMLElementAnchorData;
_HTMLElementAnchorData_htmlElement = new WeakMap(), _HTMLElementAnchorData_viewerHtmlElement = new WeakMap(), _HTMLElementAnchorData_data = new WeakMap(), _HTMLElementAnchorData_format = new WeakMap(), _HTMLElementAnchorData_hideable = new WeakMap(), _HTMLElementAnchorData_intersectionTarget = new WeakMap(), _HTMLElementAnchorData_location = new WeakMap(), _HTMLElementAnchorData_viewers = new WeakMap();
//# sourceMappingURL=HTMLElementAnchorData.js.map