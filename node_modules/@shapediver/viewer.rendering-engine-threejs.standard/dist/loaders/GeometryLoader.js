"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeometryLoader = void 0;
const THREE = __importStar(require("three"));
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const tsyringe_1 = require("tsyringe");
const SDObject_1 = require("../types/SDObject");
class GeometryLoader {
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        this._geometryCache = {};
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
        this._counter = 0;
    }
    emptyGeometryCache() {
        this._geometryCache = {};
    }
    removeFromGeometryCache(id) {
        if (this._geometryCache[id])
            delete this._geometryCache[id];
    }
    init() { }
    load(geometry, parent) {
        var _a;
        const threeGeometry = this.loadGeometry(geometry.primitive);
        const materialSettings = {
            mode: geometry.primitive.mode,
            useVertexTangents: threeGeometry.attributes.tangent !== undefined,
            useVertexColors: threeGeometry.attributes.color !== undefined,
            useFlatShading: threeGeometry.attributes.normal === undefined,
            useMorphTargets: Object.keys(threeGeometry.morphAttributes).length > 0,
            useMorphNormals: Object.keys(threeGeometry.morphAttributes).length > 0 && threeGeometry.morphAttributes.normal !== undefined
        };
        const material = this._renderingEngine.materialLoader.load(geometry.primitive.material, materialSettings);
        const obj = new SDObject_1.SDObject(geometry.id, geometry.version);
        if (geometry.primitive.mode === viewer_shared_types_1.PRIMITIVE_MODE.POINTS) {
            obj.add(new THREE.Points(threeGeometry, material));
        }
        else if (geometry.primitive.mode === viewer_shared_types_1.PRIMITIVE_MODE.LINES) {
            obj.add(new THREE.LineSegments(threeGeometry, material));
        }
        else if (geometry.primitive.mode === viewer_shared_types_1.PRIMITIVE_MODE.LINE_LOOP) {
            obj.add(new THREE.LineLoop(threeGeometry, material));
        }
        else if (geometry.primitive.mode === viewer_shared_types_1.PRIMITIVE_MODE.LINE_STRIP) {
            obj.add(new THREE.Line(threeGeometry, material));
        }
        else if (geometry.primitive.mode === viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLES || geometry.primitive.mode === viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLE_STRIP || geometry.primitive.mode === viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLE_FAN) {
            let bufferGeometry = threeGeometry;
            if (geometry.primitive.mode === viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLE_STRIP || geometry.primitive.mode === viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLE_FAN)
                bufferGeometry = this.convertToTriangleMode(bufferGeometry, geometry.primitive.mode);
            if (material.opacity < 1 || material.alphaMap) {
                const side = material.side;
                if (side === THREE.DoubleSide) {
                    const materialBack = material.clone();
                    materialBack.side = THREE.BackSide;
                    obj.add(new THREE.Mesh(bufferGeometry, materialBack));
                    const materialFront = material.clone();
                    materialFront.side = THREE.FrontSide;
                    obj.add(new THREE.Mesh(bufferGeometry, materialFront));
                }
                else {
                    obj.add(new THREE.Mesh(bufferGeometry, material));
                }
            }
            else {
                obj.add(new THREE.Mesh(bufferGeometry, material));
            }
            obj.children.forEach(m => m.castShadow = true);
            obj.children.forEach(m => m.receiveShadow = true);
        }
        else {
            throw new viewer_shared_services_1.SDError(`GeometryLoader.load: Unrecognized primitive mode ${geometry.primitive.mode}.`);
        }
        if (((_a = geometry.primitive.material) === null || _a === void 0 ? void 0 : _a.alphaMode) === viewer_shared_types_1.MATERIAL_ALPHA.BLEND)
            obj.children.forEach(m => { m.material.transparent = true; m.material.depthWrite = false; });
        obj.children.forEach(m => {
            m.geometry.boundingBox = new THREE.Box3(new THREE.Vector3(geometry.boundingBox.min[0], geometry.boundingBox.min[1], geometry.boundingBox.min[2]), new THREE.Vector3(geometry.boundingBox.max[0], geometry.boundingBox.max[1], geometry.boundingBox.max[2]));
            m.geometry.boundingSphere = new THREE.Sphere(new THREE.Vector3(geometry.boundingBox.boundingSphere.center[0], geometry.boundingBox.boundingSphere.center[1], geometry.boundingBox.boundingSphere.center[2]), geometry.boundingBox.boundingSphere.radius);
            m.geometry.userData = {
                SDid: geometry.id,
                SDversion: geometry.version
            };
            m.renderOrder = geometry.renderOrder;
            obj.add(m);
        });
        this._geometryCache[geometry.id + '_' + geometry.version] = obj;
        parent.add(obj);
        return geometry.boundingBox.clone().applyMatrix(geometry.matrix);
    }
    loadGeometry(primitive) {
        let geometry = new THREE.BufferGeometry();
        for (let attributeId in primitive.attributes) {
            const bufferAttribute = primitive.attributes[attributeId];
            let buffer;
            if (bufferAttribute.byteStride && bufferAttribute.byteStride !== bufferAttribute.itemBytes) {
                const ib = new THREE.InterleavedBuffer(bufferAttribute.array, bufferAttribute.byteStride / bufferAttribute.elementBytes);
                buffer = new THREE.InterleavedBufferAttribute(ib, bufferAttribute.itemSize, (bufferAttribute.byteOffset % bufferAttribute.byteStride) / bufferAttribute.elementBytes, bufferAttribute.normalized);
            }
            else {
                buffer = new THREE.BufferAttribute(bufferAttribute.array, bufferAttribute.itemSize, (attributeId === 'COLOR_0' || attributeId === 'COLOR0' || attributeId === 'COLOR') ? true : bufferAttribute.normalized);
            }
            if (bufferAttribute.sparse) {
                if (bufferAttribute.array !== null) {
                    buffer = new THREE.BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
                }
                for (let i = 0, il = bufferAttribute.sparseIndices.length; i < il; i++) {
                    const index = bufferAttribute.sparseIndices[i];
                    buffer.setX(index, bufferAttribute.sparseValues[i * bufferAttribute.itemSize]);
                    if (bufferAttribute.itemSize >= 2)
                        buffer.setY(index, bufferAttribute.sparseValues[i * bufferAttribute.itemSize + 1]);
                    if (bufferAttribute.itemSize >= 3)
                        buffer.setZ(index, bufferAttribute.sparseValues[i * bufferAttribute.itemSize + 2]);
                    if (bufferAttribute.itemSize >= 4)
                        buffer.setW(index, bufferAttribute.sparseValues[i * bufferAttribute.itemSize + 3]);
                    if (bufferAttribute.itemSize >= 5)
                        throw new viewer_shared_services_1.SDError('GeometryLoader.loadGeometry: Unsupported itemSize in sparse BufferAttribute.');
                }
            }
            if (attributeId === 'NORMAL') {
                let blnNormalsOk = false;
                for (let index = 0; index < 10; ++index) {
                    if (Math.abs(bufferAttribute.array[index * 3]) > 0.001) {
                        blnNormalsOk = true;
                        break;
                    }
                    if (Math.abs(bufferAttribute.array[index * 3 + 1]) > 0.001) {
                        blnNormalsOk = true;
                        break;
                    }
                    if (Math.abs(bufferAttribute.array[index * 3 + 2]) > 0.001) {
                        blnNormalsOk = true;
                        break;
                    }
                }
                if (!blnNormalsOk) {
                    geometry.computeVertexNormals();
                    continue;
                }
            }
            switch (attributeId) {
                case 'POSITION':
                    geometry.setAttribute('position', buffer);
                    break;
                case 'NORMAL':
                    geometry.setAttribute('normal', buffer);
                    break;
                case 'TEXCOORD_0':
                case 'TEXCOORD0':
                case 'TEXCOORD':
                case 'UV':
                    geometry.setAttribute('uv', buffer);
                    break;
                case 'TEXCOORD_1':
                    geometry.setAttribute('uv2', buffer);
                    break;
                case 'COLOR_0':
                case 'COLOR0':
                case 'COLOR':
                    geometry.setAttribute('color', buffer);
                    break;
                case 'WEIGHT':
                    geometry.setAttribute('skinWeight', buffer);
                    break;
                case 'JOINT':
                    geometry.setAttribute('skinIndex', buffer);
                    break;
                case 'TANGENT':
                    geometry.setAttribute('tangent', buffer);
                    break;
                default:
                    this._logger.warn(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, `GeometryLoader.loadGeometry: Unrecognized attribute id ${attributeId}.`);
            }
            if (primitive.indices)
                geometry.setIndex(new THREE.BufferAttribute(primitive.indices.array, primitive.indices.itemSize));
        }
        return geometry;
    }
    convertToTriangleMode(geometry, drawMode) {
        let index = geometry.getIndex();
        if (index === null) {
            const indices = [];
            const position = geometry.getAttribute('position');
            if (position !== undefined) {
                for (let i = 0; i < position.count; i++)
                    indices.push(i);
                geometry.setIndex(indices);
                index = geometry.getIndex();
            }
            else {
                this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, new viewer_shared_services_1.SDError('GeometryLoader.convertToTriangleMode: Undefined position attribute. Processing not possible.'));
                return geometry;
            }
        }
        if (index === null) {
            this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, new viewer_shared_services_1.SDError('GeometryLoader.convertToTriangleMode: Undefined index. Processing not possible.'));
            return geometry;
        }
        const numberOfTriangles = index.count - 2;
        const newIndices = [];
        if (drawMode === viewer_shared_types_1.PRIMITIVE_MODE.TRIANGLE_FAN) {
            for (let i = 1; i <= numberOfTriangles; i++) {
                newIndices.push(index.getX(0));
                newIndices.push(index.getX(i));
                newIndices.push(index.getX(i + 1));
            }
        }
        else {
            for (let i = 0; i < numberOfTriangles; i++) {
                if (i % 2 === 0) {
                    newIndices.push(index.getX(i));
                    newIndices.push(index.getX(i + 1));
                    newIndices.push(index.getX(i + 2));
                }
                else {
                    newIndices.push(index.getX(i + 2));
                    newIndices.push(index.getX(i + 1));
                    newIndices.push(index.getX(i));
                }
            }
        }
        if ((newIndices.length / 3) !== numberOfTriangles) {
            this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, new viewer_shared_services_1.SDError('GeometryLoader.convertToTriangleMode:Unable to generate correct amount of triangle.'));
            return geometry;
        }
        const newGeometry = geometry.clone();
        newGeometry.setIndex(newIndices);
        return newGeometry;
    }
}
exports.GeometryLoader = GeometryLoader;
//# sourceMappingURL=GeometryLoader.js.map