"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MaterialLoader = void 0;
const THREE = __importStar(require("three"));
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const PCSS_1 = require("../shaders/PCSS");
const SpecularGlossinessMaterial_1 = require("../materials/SpecularGlossinessMaterial");
class MaterialLoader {
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        this._defaultColor = '#00fff7';
        this._materialCache = {};
        this._blending = 0.0;
        this._envMap = null;
        this._envMapIntensity = 1;
        this._height = 1020;
        this._lightSizeUV = 0.025;
        this._pointSize = 1.0;
        this._textureEncoding = THREE.LinearEncoding;
        this._maxMapCount = 0;
        let shader = THREE.ShaderChunk.shadowmap_pars_fragment;
        if (!shader.includes('PCSS implementation')) {
            shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP' + PCSS_1.main);
            shader = shader.replace(shader.substr(shader.indexOf('#if defined( SHADOWMAP_TYPE_PCF )'), shader.indexOf('#elif defined( SHADOWMAP_TYPE_PCF_SOFT )') - shader.indexOf('#if defined( SHADOWMAP_TYPE_PCF )')), '#if defined( SHADOWMAP_TYPE_PCF )\n' + PCSS_1.entry);
        }
        THREE.ShaderChunk.shadowmap_pars_fragment = shader;
        THREE.ShaderChunk.envmap_fragment = THREE.ShaderChunk.envmap_fragment.replace(`vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );`, `vec4 envColor = textureCubeUV( envMap, reflectVec.xzy, 0.0 );`);
        THREE.ShaderChunk.envmap_physical_pars_fragment = THREE.ShaderChunk.envmap_physical_pars_fragment.replace(`vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );`, `vec4 envMapColor = textureCubeUV( envMap, worldNormal.xzy, 1.0 );`);
        THREE.ShaderChunk.envmap_physical_pars_fragment = THREE.ShaderChunk.envmap_physical_pars_fragment.replace(`vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );`, `vec4 envMapColor = textureCubeUV( envMap, reflectVec.xzy, roughness );`);
    }
    assignEnvironmentMap(e) {
        this._envMap = e;
        for (let m in this._materialCache) {
            if ((this._materialCache[m] instanceof THREE.MeshStandardMaterial || this._materialCache[m] instanceof THREE.MeshBasicMaterial)
                && !this._materialCache[m].KHR_materials_unlit) {
                this._materialCache[m].envMap = e;
                this._materialCache[m].needsUpdate = true;
            }
        }
    }
    assignEnvironmentMapIntensity(e) {
        this._envMapIntensity = e;
        for (let m in this._materialCache) {
            if ((this._materialCache[m] instanceof THREE.MeshStandardMaterial)
                && !this._materialCache[m].KHR_materials_unlit) {
                this._materialCache[m].envMapIntensity = e;
                this._materialCache[m].needsUpdate = true;
            }
        }
    }
    assignPointSize(p) {
        const height = this._renderingEngine.renderer ? this._renderingEngine.renderer.getSize(new THREE.Vector2()).y : 1080;
        if (height === this._height && p * (this._height / 1080) === this._pointSize)
            return;
        this._height = height;
        this._pointSize = p * (this._height / 1080);
        for (let m in this._materialCache) {
            if (this._materialCache[m] instanceof THREE.PointsMaterial) {
                this._materialCache[m].size = this._pointSize;
                this._materialCache[m].needsUpdate = true;
            }
        }
    }
    assignTextureEncoding(e) {
        this._textureEncoding = e;
        for (let m in this._materialCache) {
            if (this._materialCache[m] instanceof THREE.MeshStandardMaterial) {
                if (this._materialCache[m].emissiveMap)
                    this._materialCache[m].emissiveMap.encoding = e;
                if (this._materialCache[m].map)
                    this._materialCache[m].map.encoding = e;
                this._materialCache[m].needsUpdate = true;
            }
        }
    }
    emptyMaterialCache() {
        this._materialCache = {};
    }
    removeFromMaterialCache(id) {
        if (this._materialCache[id])
            delete this._materialCache[id];
    }
    init() { }
    load(materialProperties, materialSettings) {
        let mapCount = 0;
        const properties = {};
        if (materialProperties) {
            properties.alphaTest = materialProperties.alphaCutoff;
            if (materialProperties.shading !== undefined)
                properties.flatShading = materialProperties.shading !== 'smooth';
            if (materialProperties.opacity !== undefined) {
                properties.opacity = materialProperties.opacity;
                properties.transparent = properties.opacity < 1;
                properties.depthWrite = !(properties.opacity < 1);
            }
            if (materialProperties.alphaMap !== undefined) {
                properties.alphaMap = this.createTexture(materialProperties.alphaMap);
                properties.transparent = true;
                properties.depthWrite = false;
                mapCount++;
            }
            if (materialProperties.aoMap !== undefined) {
                properties.aoMap = this.createTexture(materialProperties.aoMap);
                mapCount++;
            }
            if (materialProperties.aoMapIntensity !== undefined) {
                properties.aoMapIntensity = materialProperties.aoMapIntensity;
            }
            if (materialProperties.bumpMap !== undefined) {
                properties.bumpMap = this.createTexture(materialProperties.bumpMap);
                mapCount++;
            }
            properties.bumpScale = materialProperties.bumpScale;
            if (materialProperties.color !== undefined)
                properties.color = new THREE.Color(materialProperties.color);
            if (!materialProperties.color !== undefined && materialProperties.map !== undefined && materialProperties.map.color !== undefined)
                properties.color = new THREE.Color(materialProperties.map.color);
            if (!materialProperties.color !== undefined && materialProperties.map !== undefined && materialProperties.map.color !== undefined && !(materialSettings !== undefined && materialSettings.useVertexColors))
                properties.color = new THREE.Color(this._defaultColor);
            if ((materialSettings !== undefined && materialSettings.useVertexColors) && materialProperties.color === this._defaultColor)
                properties.color = new THREE.Color('#d3d3d3');
            if (materialProperties.emissiveness !== undefined)
                properties.emissive = new THREE.Color(materialProperties.emissiveness);
            if (materialProperties.emissiveMap !== undefined) {
                properties.emissiveMap = this.createTexture(materialProperties.emissiveMap);
                properties.emissiveMap.encoding = this._textureEncoding;
                mapCount++;
            }
            properties.envMap = this._envMap;
            properties.envMapIntensity = this._envMapIntensity;
            if (materialProperties.map !== undefined) {
                properties.map = this.createTexture(materialProperties.map);
                properties.map.encoding = this._textureEncoding;
                mapCount++;
            }
            properties.metalness = materialProperties.metalness;
            properties.roughness = materialProperties.roughness;
            if (materialProperties.metalnessRoughnessMap !== undefined) {
                properties.metalnessMap = this.createTexture(materialProperties.metalnessRoughnessMap);
                properties.roughnessMap = properties.metalnessMap;
                mapCount++;
            }
            else {
                if (materialProperties.metalnessMap !== undefined) {
                    properties.metalnessMap = this.createTexture(materialProperties.metalnessMap);
                    mapCount++;
                }
                if (materialProperties.roughnessMap !== undefined) {
                    properties.roughnessMap = this.createTexture(materialProperties.roughnessMap);
                    mapCount++;
                }
            }
            if (materialProperties.normalMap !== undefined) {
                properties.normalMap = this.createTexture(materialProperties.normalMap);
                mapCount++;
            }
            if (materialProperties.normalScale !== undefined)
                properties.normalScale = new THREE.Vector2(materialProperties.normalScale, -materialProperties.normalScale);
            if (materialProperties.side !== undefined)
                properties.side = materialProperties.side === viewer_shared_types_1.MATERIAL_SIDE.BACK ? THREE.BackSide : materialProperties.side === viewer_shared_types_1.MATERIAL_SIDE.FRONT ? THREE.FrontSide : THREE.DoubleSide;
            if (materialProperties.KHR_materials_pbrSpecularGlossiness !== undefined)
                properties.KHR_materials_pbrSpecularGlossiness = materialProperties.KHR_materials_pbrSpecularGlossiness;
            if (properties.KHR_materials_pbrSpecularGlossiness === true) {
                properties.specular = materialProperties.specular;
                properties.glossiness = materialProperties.glossiness;
                if (materialProperties.specularGlossinessMap !== undefined) {
                    properties.specularMap = this.createTexture(materialProperties.specularGlossinessMap);
                    properties.glossinessMap = properties.specularMap;
                    mapCount++;
                }
                else {
                    if (materialProperties.specularMap !== undefined) {
                        properties.specularMap = this.createTexture(materialProperties.specularMap);
                        mapCount++;
                    }
                    if (materialProperties.glossinessMap !== undefined) {
                        properties.glossinessMap = this.createTexture(materialProperties.glossinessMap);
                        mapCount++;
                    }
                }
            }
            if (materialProperties.KHR_materials_unlit !== undefined)
                properties.KHR_materials_unlit = materialProperties.KHR_materials_unlit;
        }
        else {
            properties.color = new THREE.Color(this._defaultColor);
            if (materialSettings !== undefined && materialSettings.useVertexColors)
                properties.color = new THREE.Color('#d3d3d3');
            properties.side = THREE.DoubleSide;
        }
        let material;
        if (materialSettings && materialSettings.mode === 0) {
            properties.size = this._pointSize;
            material = new THREE.PointsMaterial(properties);
        }
        else if (materialSettings && (materialSettings.mode === 1 || materialSettings.mode === 2 || materialSettings.mode === 3)) {
            material = new THREE.LineBasicMaterial(properties);
        }
        else {
            if (properties.KHR_materials_pbrSpecularGlossiness === true) {
                material = new SpecularGlossinessMaterial_1.SpecularGlossinessMaterial(properties);
                material.KHR_materials_pbrSpecularGlossiness = true;
                const before = material.onBeforeCompile;
                material.onBeforeCompile = (shader, renderer) => {
                    before(shader, renderer);
                    shader.uniforms.lightSizeUV = { value: this._lightSizeUV };
                    shader.uniforms.blending = { value: this._blending };
                    material.userData.shader = shader;
                };
            }
            else if (properties.KHR_materials_unlit === true) {
                if (properties.envMap)
                    delete properties.envMap;
                material = new THREE.MeshBasicMaterial(properties);
                material.KHR_materials_unlit = true;
            }
            else {
                material = new THREE.MeshStandardMaterial(properties);
                material.onBeforeCompile = (shader) => {
                    shader.uniforms.lightSizeUV = { value: this._lightSizeUV };
                    shader.uniforms.blending = { value: this._blending };
                    material.userData.shader = shader;
                };
            }
        }
        if (materialSettings && materialSettings.useVertexTangents) {
            material.vertexTangents = true;
            if (material.normalScale)
                material.normalScale.y *= -1;
            if (material.clearcoatNormalScale)
                material.clearcoatNormalScale.y *= -1;
        }
        if (materialSettings && materialSettings.useVertexColors)
            material.vertexColors = true;
        if (materialSettings && materialSettings.useFlatShading)
            material.flatShading = true;
        if (materialSettings && materialSettings.useMorphTargets)
            material.morphTargets = true;
        if (materialSettings && materialSettings.useMorphNormals)
            material.morphNormals = true;
        material.needsUpdate = true;
        if (materialProperties) {
            material.userData = {
                SDid: materialProperties.id,
                SDversion: materialProperties.version
            };
            this._materialCache[materialProperties.id + '_' + materialProperties.version] = material;
        }
        this.maxMapCount = Math.max(this.maxMapCount, mapCount);
        return material;
    }
    updateMaterials() {
        for (let m in this._materialCache)
            this._materialCache[m].needsUpdate = true;
    }
    updateSoftShadow(lightSizeUV, blending) {
        this._lightSizeUV = lightSizeUV;
        this._blending = blending;
        for (let m in this._materialCache) {
            if (this._materialCache[m].userData.shader) {
                this._materialCache[m].userData.shader.uniforms.lightSizeUV.value = lightSizeUV;
                this._materialCache[m].userData.shader.uniforms.blending.value = blending;
            }
        }
    }
    createTexture(map) {
        const texture = new THREE.Texture(map.image);
        texture.format = THREE.RGBAFormat;
        texture.minFilter = (() => {
            switch (map.minFilter) {
                case viewer_shared_types_1.TEXTURE_FILTERING.NEAREST:
                    return THREE.NearestFilter;
                case viewer_shared_types_1.TEXTURE_FILTERING.NEAREST_MIPMAP_NEAREST:
                    return THREE.NearestMipMapNearestFilter;
                case viewer_shared_types_1.TEXTURE_FILTERING.LINEAR_MIPMAP_NEAREST:
                    return THREE.LinearMipMapNearestFilter;
                case viewer_shared_types_1.TEXTURE_FILTERING.NEAREST_MIPMAP_LINEAR:
                    return THREE.NearestMipMapLinearFilter;
                case viewer_shared_types_1.TEXTURE_FILTERING.LINEAR:
                    return THREE.LinearFilter;
                case viewer_shared_types_1.TEXTURE_FILTERING.LINEAR_MIPMAP_LINEAR:
                default:
                    return THREE.LinearMipMapLinearFilter;
            }
        })();
        texture.magFilter = (() => {
            switch (map.magFilter) {
                case viewer_shared_types_1.TEXTURE_FILTERING.NEAREST:
                    return THREE.NearestFilter;
                case viewer_shared_types_1.TEXTURE_FILTERING.LINEAR:
                default:
                    return THREE.LinearFilter;
            }
        })();
        texture.wrapS = (() => {
            switch (map.wrapS) {
                case viewer_shared_types_1.TEXTURE_WRAPPING.CLAMP_TO_EDGE:
                    return THREE.ClampToEdgeWrapping;
                case viewer_shared_types_1.TEXTURE_WRAPPING.MIRRORED_REPEAT:
                    return THREE.MirroredRepeatWrapping;
                case viewer_shared_types_1.TEXTURE_WRAPPING.REPEAT:
                default:
                    return THREE.RepeatWrapping;
            }
        })();
        texture.wrapT = (() => {
            switch (map.wrapT) {
                case viewer_shared_types_1.TEXTURE_WRAPPING.CLAMP_TO_EDGE:
                    return THREE.ClampToEdgeWrapping;
                case viewer_shared_types_1.TEXTURE_WRAPPING.MIRRORED_REPEAT:
                    return THREE.MirroredRepeatWrapping;
                case viewer_shared_types_1.TEXTURE_WRAPPING.REPEAT:
                default:
                    return THREE.RepeatWrapping;
            }
        })();
        texture.center = new THREE.Vector2(map.center[0], map.center[1]);
        texture.offset = new THREE.Vector2(map.offset[0], map.offset[1]);
        texture.repeat = new THREE.Vector2(map.repeat[0], map.repeat[1]);
        texture.rotation = map.rotation;
        texture.flipY = map.flipY;
        texture.needsUpdate = true;
        return texture;
    }
    get maxMapCount() {
        return this._maxMapCount;
    }
    set maxMapCount(value) {
        this._maxMapCount = value;
    }
}
exports.MaterialLoader = MaterialLoader;
//# sourceMappingURL=MaterialLoader.js.map