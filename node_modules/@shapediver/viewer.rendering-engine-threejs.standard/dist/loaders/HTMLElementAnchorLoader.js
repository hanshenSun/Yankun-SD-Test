"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HTMLElementAnchorLoader = void 0;
const gl_matrix_1 = require("gl-matrix");
class HTMLElementAnchorLoader {
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        this._htmlElements = {};
        this._parentDiv = document.createElement('div');
        this._parentDiv.style.userSelect = 'none';
        this._parentDiv.style.cursor = 'default';
        this._parentDiv.style.pointerEvents = 'none';
        this._parentDiv.style.overflow = 'hidden';
        this._parentDiv.style.position = 'absolute';
        this._parentDiv.style.width = '100%';
        this._parentDiv.style.height = '100%';
        this._parentDiv.style.left = '0%';
        this._parentDiv.style.top = '0%';
    }
    get parentDiv() {
        return this._parentDiv;
    }
    adjustPositions(scaleWidth, scaleHeight) {
        for (let anchorId in this._htmlElements) {
            const anchor = this._htmlElements[anchorId];
            const { page, container, client, hidden } = this._renderingEngine.sceneTracingManager.convert3Dto2D(gl_matrix_1.vec3.clone(anchor.location));
            const htmlElement = anchor.createViewerHtmlElement(this._renderingEngine.id);
            if (!htmlElement)
                continue;
            htmlElement.style.display = '';
            if (hidden)
                htmlElement.style.display = 'none';
            let x, y;
            if (anchor.data.position && anchor.data.position.horizontal === 'right') {
                x = container[0] - htmlElement.offsetWidth;
            }
            else if (anchor.data.position && anchor.data.position.horizontal === 'left') {
                x = container[0];
            }
            else {
                x = container[0] - htmlElement.offsetWidth / 2;
            }
            if (anchor.data.position && anchor.data.position.vertical === 'bottom') {
                y = container[1] - htmlElement.offsetHeight;
            }
            else if (anchor.data.position && anchor.data.position.vertical === 'top') {
                y = container[1];
            }
            else {
                y = container[1] - htmlElement.offsetHeight / 2;
            }
            x = x / scaleWidth;
            y = y / scaleHeight;
            htmlElement.style.left = x + 'px';
            htmlElement.style.top = y + 'px';
        }
    }
    init() {
        var _a;
        (_a = this._renderingEngine.canvas.canvasElement.parentNode) === null || _a === void 0 ? void 0 : _a.appendChild(this._parentDiv);
    }
    load(anchor) {
        const htmlElement = anchor.createViewerHtmlElement(this._renderingEngine.id);
        if (!htmlElement)
            return;
        this._parentDiv.appendChild(htmlElement);
        this._htmlElements[anchor.id + '_' + anchor.version] = anchor;
    }
    removeData(id, version) {
        const anchor = this._htmlElements[id + '_' + version];
        if (anchor && anchor.getViewerHtmlElement(this._renderingEngine.id)) {
            this._parentDiv.removeChild(anchor.getViewerHtmlElement(this._renderingEngine.id));
            delete this._htmlElements[id + '_' + version];
        }
    }
    toggleBlur(toggle) {
        if (toggle) {
            if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1 && navigator.userAgent.toLowerCase().indexOf('android') > -1)
                return;
            this._parentDiv.style.filter = 'blur(3px)';
        }
        else {
            this._parentDiv.style.filter = '';
        }
    }
}
exports.HTMLElementAnchorLoader = HTMLElementAnchorLoader;
//# sourceMappingURL=HTMLElementAnchorLoader.js.map