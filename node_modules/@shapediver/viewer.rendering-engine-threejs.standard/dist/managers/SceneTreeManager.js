"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SceneTreeManager = void 0;
const THREE = __importStar(require("three"));
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_math_1 = require("@shapediver/viewer.shared.math");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const viewer_rendering_engine_light_engine_1 = require("@shapediver/viewer.rendering-engine.light-engine");
const gl_matrix_1 = require("gl-matrix");
const tsyringe_1 = require("tsyringe");
const SDObject_1 = require("../types/SDObject");
const ThreejsData_1 = require("../types/ThreejsData");
class SceneTreeManager {
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        this._eventEngine = tsyringe_1.container.resolve(viewer_shared_services_1.EventEngine);
        this._scene = new THREE.Scene();
        this._stateEngine = tsyringe_1.container.resolve(viewer_shared_services_1.StateEngine);
        this._tree = tsyringe_1.container.resolve(viewer_shared_node_tree_1.Tree);
        this._boundingBox = new viewer_shared_math_1.Box();
        this._scene.background = new THREE.Color('#ffffff');
    }
    get boundingBox() {
        return this._boundingBox;
    }
    get scene() {
        return this._scene;
    }
    convertData(data, obj) {
        let dataChild = obj.children.find(oc => oc.SDid === data.id && oc.SDversion === data.version);
        if (!dataChild)
            dataChild = new SDObject_1.SDObject(data.id, data.version);
        obj.add(dataChild);
        switch (true) {
            case data instanceof viewer_shared_types_1.GeometryData:
                return this._renderingEngine.geometryLoader.load(data, dataChild);
            case data instanceof ThreejsData_1.ThreejsData:
                dataChild.add(data.obj);
                break;
            case data instanceof viewer_shared_types_1.MaterialData:
                break;
            case data instanceof viewer_rendering_engine_light_engine_1.AbstractLight:
                this._renderingEngine.lightLoader.load(data, dataChild, this._scene, this._boundingBox);
                break;
            case data instanceof viewer_shared_types_1.HTMLElementAnchorData:
                this._renderingEngine.htmlElementAnchorLoader.load(data);
                break;
            case data instanceof viewer_shared_types_1.AnimationData:
                break;
            default:
                break;
        }
        return new viewer_shared_math_1.Box();
    }
    init() { }
    isEmpty() {
        return ((this._boundingBox.min[0] === 0 && this._boundingBox.min[1] === 0 && this._boundingBox.min[2] === 0 &&
            this._boundingBox.max[0] === 0 && this._boundingBox.max[1] === 0 && this._boundingBox.max[2] === 0) || this._boundingBox.isEmpty());
    }
    updateSceneTree(root, lightEngine) {
        const oldBB = this._boundingBox.clone();
        this._boundingBox = new viewer_shared_math_1.Box();
        this._renderingEngine.lightLoader.shadowMapCount = 0;
        if (!this._mainNode) {
            this._mainNode = new SDObject_1.SDObject(root.id, root.version);
            this._scene.add(this._mainNode);
        }
        this.updateNode(root, this._mainNode);
        this._boundingBox = root.boundingBox.clone();
        const lightScene = lightEngine.lightScene;
        if (lightScene) {
            const lightSceneChildren = this._mainNode.children.filter(oc => lightScene.node.id === oc.SDid);
            if (lightSceneChildren.length > 1) {
                this.updateNode(lightScene.node, lightSceneChildren[0]);
            }
            else {
                const lightSceneChild = new SDObject_1.SDObject(lightScene.node.id, lightScene.node.version);
                this._mainNode.add(lightSceneChild);
                this.updateNode(lightScene.node, lightSceneChild);
            }
        }
        if (!this._boundingBox.isEmpty())
            this._boundingBox.applyMatrix(root.nodeMatrix);
        if (!(this._boundingBox.min[0] === oldBB.min[0] && this._boundingBox.min[1] === oldBB.min[1] && this._boundingBox.min[2] === oldBB.min[2] &&
            this._boundingBox.max[0] === oldBB.max[0] && this._boundingBox.max[1] === oldBB.max[1] && this._boundingBox.max[2] === oldBB.max[2]) && !this._boundingBox.isEmpty()) {
            if (!this._stateEngine.boundingBoxCreated.resolved)
                this._stateEngine.boundingBoxCreated.resolve(true);
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.SCENE.SCENE_BOUNDING_BOX_CHANGE, { viewerId: this._renderingEngine.id, boundingBox: {
                    min: gl_matrix_1.vec3.clone(this._boundingBox.min),
                    max: gl_matrix_1.vec3.clone(this._boundingBox.max),
                } });
        }
        this._renderingEngine.renderingManager.evaluateTextureUnitCount(this._renderingEngine.lightLoader.shadowMapCount + this._renderingEngine.materialLoader.maxMapCount);
    }
    updateNodeTransformations(node = this._tree.root, obj = this._mainNode) {
        if (!node || !obj)
            return;
        if (node.excludeViewers.includes(this._renderingEngine.id))
            return;
        obj.visible = node.visible;
        obj.applyTransformation(node.nodeMatrix);
        for (let i = 0, len = node.children.length; i < len; i++) {
            const nodeChild = node.children[i];
            if (!nodeChild)
                continue;
            const objChild = obj.children.find(oc => oc.SDid === nodeChild.id);
            this.updateNodeTransformations(nodeChild, objChild);
        }
    }
    updateNode(node, obj) {
        if (node.excludeViewers.includes(this._renderingEngine.id))
            return;
        obj.visible = node.visible;
        obj.applyTransformation(node.nodeMatrix);
        node.boundingBox = new viewer_shared_math_1.Box();
        for (let i = 0, len = node.data.length; i < len; i++) {
            const bb = this.convertData(node.data[i], obj);
            node.boundingBox.union(bb);
        }
        const nodeIds = [];
        for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            if (child)
                nodeIds.push(child.id);
        }
        const dataIds = node.data.map(d => d.id);
        const dataVersions = node.data.map(d => d.version);
        const childrenToRemove = obj.children.filter(oc => (!nodeIds.includes(oc.SDid)) && !(dataIds.includes(oc.SDid) && dataVersions.includes(oc.SDversion)));
        for (const objChild of childrenToRemove) {
            obj.remove(objChild);
            objChild.traverse((o) => {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
                if (o instanceof SDObject_1.SDObject && o.children.length === 0)
                    this._renderingEngine.htmlElementAnchorLoader.removeData(o.SDid, o.SDversion);
                if (o instanceof THREE.Mesh) {
                    this._renderingEngine.geometryLoader.removeFromGeometryCache(o.geometry.userData.SDid + '_' + o.geometry.userData.SDversion);
                    this._renderingEngine.materialLoader.removeFromMaterialCache(o.material.userData.SDid + '_' + o.material.userData.SDversion);
                    for (const key in o.geometry.attributes)
                        o.geometry.deleteAttribute(key);
                    o.geometry.setIndex(null);
                    o.geometry.dispose();
                    if (o.material.alphaMap)
                        (_a = o.material.alphaMap) === null || _a === void 0 ? void 0 : _a.dispose();
                    if (o.material.aoMap)
                        (_b = o.material.aoMap) === null || _b === void 0 ? void 0 : _b.dispose();
                    if (o.material.bumpMap)
                        (_c = o.material.bumpMap) === null || _c === void 0 ? void 0 : _c.dispose();
                    if (o.material.map)
                        (_d = o.material.map) === null || _d === void 0 ? void 0 : _d.dispose();
                    if (o.material.emissiveMap)
                        (_e = o.material.emissiveMap) === null || _e === void 0 ? void 0 : _e.dispose();
                    if (o.material.metalnessMap)
                        (_f = o.material.metalnessMap) === null || _f === void 0 ? void 0 : _f.dispose();
                    if (o.material.roughnessMap)
                        (_g = o.material.roughnessMap) === null || _g === void 0 ? void 0 : _g.dispose();
                    if (o.material.normalMap)
                        (_h = o.material.normalMap) === null || _h === void 0 ? void 0 : _h.dispose();
                    if (o.material.specularMap)
                        (_j = o.material.specularMap) === null || _j === void 0 ? void 0 : _j.dispose();
                    if (o.material.glossinessMap)
                        (_k = o.material.glossinessMap) === null || _k === void 0 ? void 0 : _k.dispose();
                    o.material.dispose();
                }
            });
        }
        for (let i = 0, len = node.children.length; i < len; i++) {
            const nodeChild = node.children[i];
            if (!nodeChild)
                continue;
            const objChild = obj.children.find(oc => oc.SDid === nodeChild.id);
            if (!objChild) {
                const newChild = new SDObject_1.SDObject(nodeChild.id, nodeChild.version);
                obj.add(newChild);
                this.updateNode(nodeChild, newChild);
            }
            else if (objChild.SDversion !== nodeChild.version) {
                this.updateNode(nodeChild, objChild);
            }
            if (!nodeChild.boundingBox.isEmpty())
                node.boundingBox.union(nodeChild.boundingBox);
        }
        if (!node.boundingBox.isEmpty())
            node.boundingBox.applyMatrix(node.nodeMatrix);
    }
}
exports.SceneTreeManager = SceneTreeManager;
//# sourceMappingURL=SceneTreeManager.js.map