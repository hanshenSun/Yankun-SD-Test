"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AnimationManager = void 0;
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const tsyringe_1 = require("tsyringe");
const gl_matrix_1 = require("gl-matrix");
class AnimationManager {
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        this._systemInfo = tsyringe_1.container.resolve(viewer_shared_services_1.SystemInfo);
    }
    init() { }
    update(deltaTime) {
        const animations = this._renderingEngine.animations;
        let running = false;
        for (let i = 0; i < animations.length; i++) {
            const animation = animations[i];
            if (animation.animationTime === -1) {
                running = true;
                animation.animationTime = 0;
            }
            if (!animation.animate)
                continue;
            running = true;
            animation.animationTime += deltaTime;
            if (animation.animationTime / 1000.0 > animation.duration) {
                if (animation.repeat) {
                    animation.startAnimation();
                }
                else {
                    animation.stopAnimation();
                }
            }
            const animationDuration = animation.duration;
            const currentAnimationDeltaTime = (animation.animationTime / 1000.0) % animationDuration;
            for (let j = 0; j < animation.tracks.length; j++) {
                const track = animation.tracks[j];
                const id = animation.id + '_' + j;
                const prevAnimation = track.node.transformations.filter(t => t.id === id);
                track.node.transformations = track.node.transformations.filter((el) => {
                    return !prevAnimation.includes(el);
                });
                for (let j = 1; j < track.times.length; j++) {
                    if (currentAnimationDeltaTime < track.times[j] && currentAnimationDeltaTime > track.times[j - 1]) {
                        const factor = (currentAnimationDeltaTime - track.times[j - 1]) / (track.times[j] - track.times[j - 1]);
                        if (track.path === 'rotation') {
                            let quaternion;
                            if (track.interpolation === 'step') {
                                quaternion = gl_matrix_1.quat.fromValues(track.values[(j - 1) * 4 + 0], track.values[(j - 1) * 4 + 1], track.values[(j - 1) * 4 + 2], track.values[(j - 1) * 4 + 3]);
                            }
                            else {
                                quaternion = gl_matrix_1.quat.slerp(gl_matrix_1.vec4.create(), gl_matrix_1.vec4.fromValues(track.values[(j - 1) * 4 + 0], track.values[(j - 1) * 4 + 1], track.values[(j - 1) * 4 + 2], track.values[(j - 1) * 4 + 3]), gl_matrix_1.vec4.fromValues(track.values[(j) * 4 + 0], track.values[(j) * 4 + 1], track.values[(j) * 4 + 2], track.values[(j) * 4 + 3]), factor);
                            }
                            track.node.transformations.push({
                                id,
                                matrix: gl_matrix_1.mat4.fromQuat(gl_matrix_1.mat4.create(), quaternion)
                            });
                        }
                        else if (track.path === 'translation') {
                            let vector;
                            if (track.interpolation === 'step') {
                                vector = gl_matrix_1.vec3.fromValues(track.values[(j - 1) * 3 + 0], track.values[(j - 1) * 3 + 1], track.values[(j - 1) * 3 + 2]);
                            }
                            else {
                                vector = gl_matrix_1.vec3.lerp(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(track.values[(j - 1) * 3 + 0], track.values[(j - 1) * 3 + 1], track.values[(j - 1) * 3 + 2]), gl_matrix_1.vec3.fromValues(track.values[(j) * 3 + 0], track.values[(j) * 3 + 1], track.values[(j) * 3 + 2]), factor);
                            }
                            track.node.transformations.push({
                                id,
                                matrix: gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), vector)
                            });
                        }
                        else if (track.path === 'scale') {
                            let vector;
                            if (track.interpolation === 'step') {
                                vector = gl_matrix_1.vec3.fromValues(track.values[(j - 1) * 3 + 0], track.values[(j - 1) * 3 + 1], track.values[(j - 1) * 3 + 2]);
                            }
                            else {
                                vector = gl_matrix_1.vec3.lerp(gl_matrix_1.vec3.create(), gl_matrix_1.vec3.fromValues(track.values[(j - 1) * 3 + 0], track.values[(j - 1) * 3 + 1], track.values[(j - 1) * 3 + 2]), gl_matrix_1.vec3.fromValues(track.values[(j) * 3 + 0], track.values[(j) * 3 + 1], track.values[(j) * 3 + 2]), factor);
                            }
                            track.node.transformations.push({
                                id,
                                matrix: gl_matrix_1.mat4.fromScaling(gl_matrix_1.mat4.create(), vector)
                            });
                        }
                        break;
                    }
                }
            }
        }
        return running;
    }
}
exports.AnimationManager = AnimationManager;
//# sourceMappingURL=AnimationManager.js.map