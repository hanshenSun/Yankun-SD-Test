"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SDTFEngine = void 0;
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const tsyringe_1 = require("tsyringe");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
let SDTFEngine = class SDTFEngine {
    constructor() {
        this.BINARY_EXTENSION_HEADER_LENGTH = 20;
        this._httpClient = tsyringe_1.container.resolve(viewer_shared_services_1.HttpClient);
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
    }
    loadContent(content) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const node = new viewer_shared_node_tree_1.TreeNode('sdtf');
            if (!content || (content && !content.href)) {
                this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, new viewer_shared_services_1.SDError('SDTFEngine.loadContent: Invalid content was provided to geometry engine.'), '', false);
                return node;
            }
            let axiosResponse;
            try {
                axiosResponse = yield this._httpClient.get(content.href, {
                    responseType: 'arraybuffer'
                });
            }
            catch (e) {
                if (e.response && e.response.status) {
                    this._logger.httpError(viewer_shared_services_1.LOGGINGTOPIC.SDTF, e, `SDTFEngine.loadContent: Was not able to get array buffer from uri.`, e.response.status, false);
                }
                else {
                    this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.SDTF, e, `SDTFEngine.loadContent: Was not able to get array buffer from uri.`, false);
                }
                return node;
            }
            if (!(axiosResponse.headers['content-type'] && axiosResponse.headers['content-type'] === 'model/vnd.sdtf')) {
                this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.SDTF, new viewer_shared_services_1.SDError('SDTFEngine.loadContent: Non-binary SDTF encoding not implemented.'));
                return node;
            }
            let arrayBuffer;
            if (axiosResponse.data instanceof ArrayBuffer) {
                arrayBuffer = axiosResponse.data;
            }
            else {
                arrayBuffer = axiosResponse.data.buffer;
            }
            const headerDataView = new DataView(arrayBuffer, 0, this.BINARY_EXTENSION_HEADER_LENGTH);
            const magic = String.fromCharCode(headerDataView.getUint8(0)) + String.fromCharCode(headerDataView.getUint8(1)) + String.fromCharCode(headerDataView.getUint8(2)) + String.fromCharCode(headerDataView.getUint8(3));
            if (magic !== 'sdtf') {
                this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.SDTF, new viewer_shared_services_1.SDError('SDTFEngine.loadContent: Invalid data: sdtf magic wrong.'));
                return node;
            }
            const version = headerDataView.getUint32(4, true);
            if (version !== 1) {
                this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.SDTF, new viewer_shared_services_1.SDError(`SDTFEngine.loadContent: Invalid version: sdtf loader does not support version ${version}.`));
                return node;
            }
            const totalLength = headerDataView.getUint32(8, true);
            const contentLength = headerDataView.getUint32(12, true);
            const contentFormat = headerDataView.getUint32(16, true);
            if (contentFormat !== 0) {
                this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.SDTF, new viewer_shared_services_1.SDError('SDTFEngine.loadContent: Content format is not Json (0), content invalid.'));
                return node;
            }
            this._content = JSON.parse(new TextDecoder().decode(new DataView(arrayBuffer, this.BINARY_EXTENSION_HEADER_LENGTH, contentLength)));
            this._body = arrayBuffer.slice(this.BINARY_EXTENSION_HEADER_LENGTH + contentLength, totalLength);
            try {
                const overview = {};
                for (let i = 0; i < this._content.attributes.length; i++) {
                    const attributes = this._content.attributes[i];
                    for (let key in attributes) {
                        const dataToCopy = attributes[key];
                        const dataTypehint = this._content.typeHints[dataToCopy.typeHint].name;
                        const existingEntries = overview[key] ? overview[key].filter(o => o.typeHint === dataTypehint) : [];
                        if (overview[key] && existingEntries.length > 0) {
                            const entry = existingEntries[0];
                            entry.count++;
                            if (dataTypehint === viewer_shared_types_1.PRIMITIVETYPEHINT.STRING) {
                                if (!((_a = entry.values) === null || _a === void 0 ? void 0 : _a.includes(dataToCopy.value)))
                                    (_b = entry.values) === null || _b === void 0 ? void 0 : _b.push(dataToCopy.value);
                            }
                            if (dataTypehint === viewer_shared_types_1.PRIMITIVETYPEHINT.DOUBLE ||
                                dataTypehint === viewer_shared_types_1.PRIMITIVETYPEHINT.FLOAT ||
                                dataTypehint === viewer_shared_types_1.PRIMITIVETYPEHINT.DECIMAL ||
                                dataTypehint === viewer_shared_types_1.PRIMITIVETYPEHINT.INT) {
                                entry.min = Math.min(dataToCopy.value, entry.min);
                                entry.max = Math.max(dataToCopy.value, entry.max);
                            }
                        }
                        else {
                            if (overview[key]) {
                                overview[key].push({
                                    typeHint: dataTypehint,
                                    count: 1,
                                });
                            }
                            else {
                                overview[key] = [{
                                        typeHint: dataTypehint,
                                        count: 1,
                                    }];
                            }
                            if (dataTypehint === viewer_shared_types_1.PRIMITIVETYPEHINT.STRING) {
                                overview[key][overview[key].length - 1].values = [dataToCopy.value];
                            }
                            if (dataTypehint === viewer_shared_types_1.PRIMITIVETYPEHINT.DOUBLE ||
                                dataTypehint === viewer_shared_types_1.PRIMITIVETYPEHINT.FLOAT ||
                                dataTypehint === viewer_shared_types_1.PRIMITIVETYPEHINT.DECIMAL ||
                                dataTypehint === viewer_shared_types_1.PRIMITIVETYPEHINT.INT) {
                                overview[key][overview[key].length - 1].min = dataToCopy.value;
                                overview[key][overview[key].length - 1].max = dataToCopy.value;
                            }
                        }
                    }
                }
                node.data.push(new viewer_shared_types_1.SDTFAttributeOverview(overview));
                for (let i = 0; i < this._content.chunks.length; i++) {
                    node.children.push(yield this.loadChunk(i));
                }
                return node;
            }
            catch (e) {
                if (e.response && e.response.status) {
                    this._logger.httpError(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, e, `SDTFEngine.load: Loading of sdtf failed. ${e.message}`, e.response.status, false);
                }
                else {
                    this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, e, `SDTFEngine.load: Loading of sdtf failed. ${e.message}`, false);
                }
                return new viewer_shared_node_tree_1.TreeNode('sdtf');
            }
        });
    }
    loadAttributes(attributesID) {
        if (!this._content.attributes)
            throw new viewer_shared_services_1.SDError('Attributes not available.');
        if (!this._content.attributes[attributesID])
            throw new viewer_shared_services_1.SDError('Attributes not available.');
        const attributes = this._content.attributes[attributesID];
        const data = new viewer_shared_types_1.SDTFAttributesData();
        for (let key in attributes) {
            if (attributes[key].value === undefined) {
            }
            else {
                data.attributes[key] = new viewer_shared_types_1.SDTFAttributeData(this._content.typeHints[attributes[key].typeHint].name, attributes[key].value);
            }
        }
        return data;
    }
    loadItem(itemId, index) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.items)
                throw new viewer_shared_services_1.SDError('Item not available.');
            if (!this._content.items[itemId])
                throw new viewer_shared_services_1.SDError('Item not available.');
            const item = this._content.items[itemId];
            const itemDef = new viewer_shared_node_tree_1.TreeNode(index + '');
            let attributes;
            if (item.attributes !== undefined)
                attributes = this.loadAttributes(item.attributes);
            const itemData = new viewer_shared_types_1.SDTFItemData(this._content.typeHints[item.typeHint].name, item.value, attributes === null || attributes === void 0 ? void 0 : attributes.attributes);
            itemDef.data.push(itemData);
            return itemDef;
        });
    }
    loadNode(nodeId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.nodes)
                throw new viewer_shared_services_1.SDError('Node not available.');
            if (!this._content.nodes[nodeId])
                throw new viewer_shared_services_1.SDError('Node not available.');
            const node = this._content.nodes[nodeId];
            const nodeDef = new viewer_shared_node_tree_1.TreeNode(node.name || 'node_' + nodeId);
            if (node.attributes !== undefined) {
                nodeDef.data.push(this.loadAttributes(node.attributes));
            }
            if (node.items !== undefined && node.items.length > 0) {
                for (let i = 0, len = node.items.length; i < len; i++) {
                    nodeDef.addChild(yield this.loadItem(node.items[i], i));
                }
            }
            if (node.nodes !== undefined && node.nodes.length > 0) {
                for (let i = 0, len = node.nodes.length; i < len; i++) {
                    nodeDef.addChild(yield this.loadNode(node.nodes[i]));
                }
            }
            return nodeDef;
        });
    }
    loadChunk(chunkId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.chunks)
                throw new viewer_shared_services_1.SDError('Chunks not available.');
            if (!this._content.chunks[chunkId])
                throw new viewer_shared_services_1.SDError('Chunks not available.');
            const chunk = this._content.chunks[chunkId];
            const chunkDef = new viewer_shared_node_tree_1.TreeNode(chunk.name || 'chunk_' + chunkId);
            if (chunk.attributes !== undefined) {
                chunkDef.data.push(this.loadAttributes(chunk.attributes));
            }
            if (chunk.items !== undefined && chunk.items.length > 0) {
                for (let i = 0, len = chunk.items.length; i < len; i++) {
                    chunkDef.addChild(yield this.loadItem(chunk.items[i], i));
                }
            }
            if (chunk.nodes !== undefined && chunk.nodes.length > 0) {
                for (let i = 0, len = chunk.nodes.length; i < len; i++) {
                    chunkDef.addChild(yield this.loadNode(chunk.nodes[i]));
                }
            }
            return chunkDef;
        });
    }
};
SDTFEngine = __decorate([
    tsyringe_1.singleton(),
    __metadata("design:paramtypes", [])
], SDTFEngine);
exports.SDTFEngine = SDTFEngine;
//# sourceMappingURL=SDTFEngine.js.map