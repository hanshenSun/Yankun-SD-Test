"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GLTFLoader = void 0;
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const viewer_data_engine_shared_types_1 = require("@shapediver/viewer.data-engine.shared-types");
const gl_matrix_1 = require("gl-matrix");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const tsyringe_1 = require("tsyringe");
const SDGTFLoader_1 = require("./SDGTFLoader");
class GLTFLoader {
    constructor() {
        this.BINARY_EXTENSION_HEADER_LENGTH = 20;
        this._httpClient = tsyringe_1.container.resolve(viewer_shared_services_1.HttpClient);
        this._uuidGenerator = tsyringe_1.container.resolve(viewer_shared_services_1.UuidGenerator);
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
        this._implementedExtensions = ['KHR_materials_common'];
        this._globalTransformation = gl_matrix_1.mat4.fromValues(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1);
        this._converter = tsyringe_1.container.resolve(viewer_shared_services_1.Converter);
        this._performanceEvaluator = tsyringe_1.container.resolve(viewer_shared_services_1.PerformanceEvaluator);
    }
    load(content, gltfBinary, gltfHeader, baseUri) {
        return __awaiter(this, void 0, void 0, function* () {
            this._baseUri = baseUri;
            if (gltfBinary && gltfHeader)
                this._body = gltfBinary.slice(this.BINARY_EXTENSION_HEADER_LENGTH + gltfHeader.contentLength, gltfHeader.length);
            this._content = content;
            let sdgtfNode;
            if (gltfBinary && gltfHeader)
                sdgtfNode = yield new SDGTFLoader_1.SDGTFLoader().load(gltfBinary, gltfHeader.length);
            try {
                this.validateVersionAndExtensions();
                const node = yield this.loadScene();
                if (sdgtfNode)
                    node.addChild(sdgtfNode);
                return node;
            }
            catch (e) {
                if (e.response && e.response.status) {
                    this._logger.httpError(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, e, `GLTFLoader.load: Loading of geometry failed. ${e.message}`, e.response.status, false);
                }
                else {
                    this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, e, `GLTFLoader.load: Loading of geometry failed. ${e.message}`, false);
                }
                return new viewer_shared_node_tree_1.TreeNode();
            }
        });
    }
    loadWithUrl(url) {
        return __awaiter(this, void 0, void 0, function* () {
            this._performanceEvaluator.startSection('gltfProcessing.' + url);
            let binaryGeometry;
            try {
                this._performanceEvaluator.startSection('loadGltf.' + url);
                binaryGeometry = (yield this._httpClient.get(url, {
                    responseType: 'arraybuffer'
                })).data;
                this._performanceEvaluator.endSection('loadGltf.' + url);
            }
            catch (e) {
                if (e.response && e.response.status) {
                    this._logger.httpError(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, e, `GLTFLoader.load: Initial loading of geometry failed.`, e.response.status, false);
                }
                else {
                    this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, e, `GLTFLoader.load: Initial loading of geometry failed.`, false);
                }
                return new viewer_shared_node_tree_1.TreeNode();
            }
            const headerDataView = new DataView(binaryGeometry, 0, this.BINARY_EXTENSION_HEADER_LENGTH);
            const header = {
                magic: String.fromCharCode(headerDataView.getUint8(0)) + String.fromCharCode(headerDataView.getUint8(1)) + String.fromCharCode(headerDataView.getUint8(2)) + String.fromCharCode(headerDataView.getUint8(3)),
                version: headerDataView.getUint32(4, true),
                length: headerDataView.getUint32(8, true),
                contentLength: headerDataView.getUint32(12, true),
                contentFormat: headerDataView.getUint32(16, true)
            };
            if (header.magic != 'glTF') {
                this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, new viewer_shared_services_1.SDError('GLTFLoader.load: Invalid data: glTF magic wrong.'));
                return new viewer_shared_node_tree_1.TreeNode();
            }
            const contentDataView = new DataView(binaryGeometry, this.BINARY_EXTENSION_HEADER_LENGTH, header.contentLength);
            const contentDecoded = new TextDecoder().decode(contentDataView);
            this._content = JSON.parse(contentDecoded);
            this._body = binaryGeometry.slice(this.BINARY_EXTENSION_HEADER_LENGTH + header.contentLength, header.length);
            const sdgtfNode = yield new SDGTFLoader_1.SDGTFLoader().load(binaryGeometry, header.length);
            try {
                this.validateVersionAndExtensions();
                const node = yield this.loadScene();
                node.addChild(sdgtfNode);
                this._performanceEvaluator.endSection('gltfProcessing.' + url);
                return node;
            }
            catch (e) {
                if (e.response && e.response.status) {
                    this._logger.httpError(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, e, `GLTFLoader.load: Loading of geometry failed. ${e.message}`, e.response.status, false);
                }
                else {
                    this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, e, `GLTFLoader.load: Loading of geometry failed. ${e.message}`, false);
                }
                return new viewer_shared_node_tree_1.TreeNode();
            }
        });
    }
    validateVersionAndExtensions() {
        if (this._content.extensionsUsed) {
            const notSupported = [];
            for (let i = 0; i < this._content.extensionsUsed.length; i++) {
                if (!this._implementedExtensions.includes(this._content.extensionsUsed[i]))
                    notSupported.push(this._content.extensionsUsed[i]);
            }
            if (notSupported.length > 0) {
                let message = 'Extension' + (notSupported.length === 1 ? ' ' : 's ');
                notSupported.forEach((element, index) => {
                    message += '"' + element + '"' + (index === notSupported.length - 1 ? '' : index === notSupported.length - 2 ? ' and ' : ', ');
                });
                message += (notSupported.length === 1 ? ' is' : ' are') + ' not supported, but used. Loading glTF regardless.';
                this._logger.info(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, 'GLTFLoader.validateVersionAndExtensions: ' + message);
            }
        }
    }
    loadAccessor(accessorName) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.accessors[accessorName])
                throw new viewer_shared_services_1.SDError('Accessor not available.');
            const accessor = this._content.accessors[accessorName];
            const bufferView = yield this.loadBufferView(accessor.bufferView);
            const itemSize = viewer_data_engine_shared_types_1.ACCESSORTYPE_V1[accessor.type];
            if (accessor.componentType === 5124)
                this._logger.warn(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, 'GLTFLoader.loadAccessor: The componentType for this accessor is 5124, which is not allowed. Trying to load it anyway.');
            const ArrayType = viewer_data_engine_shared_types_1.ACCESSORCOMPONENTTYPE_V1[accessor.componentType];
            const elementBytes = ArrayType.BYTES_PER_ELEMENT;
            const itemBytes = elementBytes * itemSize;
            const byteOffset = accessor.byteOffset || 0;
            const byteStride = accessor.byteStride;
            const normalized = false;
            const min = this._content.asset && ((_a = this._content.asset) === null || _a === void 0 ? void 0 : _a.generator) === "ShapeDiverGltfV1Writer" ? accessor.min || [] : [];
            const max = this._content.asset && ((_b = this._content.asset) === null || _b === void 0 ? void 0 : _b.generator) === "ShapeDiverGltfV1Writer" ? accessor.max || [] : [];
            return new viewer_shared_types_1.AttributeData(new ArrayType(bufferView), itemSize, itemBytes, byteOffset, elementBytes, normalized, accessor.count, min, max, byteStride);
        });
    }
    loadBuffer(bufferName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.buffers[bufferName])
                throw new viewer_shared_services_1.SDError('Buffer not available.');
            const buffer = this._content.buffers[bufferName];
            if (bufferName === 'binary_glTF')
                return this._body;
            if (buffer.type === 'arraybuffer') {
                const binaryGeometry = (yield this._httpClient.get(buffer.uri, {
                    responseType: 'arraybuffer'
                })).data;
                return binaryGeometry;
            }
            if (!this._body)
                throw new viewer_shared_services_1.SDError('Buffer not available.');
            return this._body;
        });
    }
    loadBufferView(bufferViewName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.bufferViews[bufferViewName])
                throw new viewer_shared_services_1.SDError('Buffer View not available.');
            const bufferView = this._content.bufferViews[bufferViewName];
            const buffer = yield this.loadBuffer(bufferView.buffer);
            const byteLength = bufferView.byteLength !== undefined ? bufferView.byteLength : 0;
            return buffer.slice(bufferView.byteOffset, bufferView.byteOffset + byteLength);
        });
    }
    loadMaterial(materialName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.materials[materialName])
                throw new viewer_shared_services_1.SDError('Material not available.');
            const material = this._content.materials[materialName];
            const materialData = new viewer_shared_types_1.MaterialData();
            if (material.name !== undefined)
                materialData.name = material.name;
            if (material.extensions && material.extensions.KHR_materials_common) {
                const technique = material.extensions.KHR_materials_common.technique;
                if (technique && technique !== 'BLINN')
                    this._logger.info(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, 'The technique ' + technique + ' is not supported. Trying to load the material either way.');
                const values = material.extensions.KHR_materials_common.values;
                if (values.hasOwnProperty('ambient'))
                    this._logger.info(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, 'GLTFLoader.loadMaterial: The value ambient was set for a material, but is not supported.');
                if (values.hasOwnProperty('doubleSided'))
                    materialData.side = values.doubleSided ? viewer_shared_types_1.MATERIAL_SIDE.DOUBLE : viewer_shared_types_1.MATERIAL_SIDE.FRONT;
                materialData.color = '#d3d3d3';
                if (values.hasOwnProperty('diffuse') && Array.isArray(values.diffuse)) {
                    materialData.color = this._converter.toColor(values.diffuse);
                    materialData.opacity = Math.max(0.0, Math.min(values.diffuse[3], 1.0));
                }
                else if (values.hasOwnProperty('diffuse') && !Array.isArray(values.diffuse)) {
                    this._logger.info(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, 'GLTFLoader.loadMaterial: The value diffuse was set for a material, but is not supported in that type.');
                }
                if (values.hasOwnProperty('emission') && Array.isArray(values.emission)) {
                    materialData.emissiveness = this._converter.toColor(values.emission);
                }
                else {
                    this._logger.info(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, 'GLTFLoader.loadMaterial: The value emission was set for a material, but is not supported in that type.');
                }
                if (values.hasOwnProperty('shininess')) {
                    materialData.metalness = Math.min(1, values.shininess);
                    materialData.roughness = 1 - Math.min(1, values.shininess);
                }
                if (values.hasOwnProperty('transparency'))
                    materialData.opacity = Math.max(0.0, Math.min(values.transparency, 1.0));
                if (values.hasOwnProperty('transparent'))
                    this._logger.info(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, 'GLTFLoader.loadMaterial: The value transparent was set for a material, but is not supported.');
                if (values.hasOwnProperty('_roughness'))
                    materialData.roughness = Math.min(1, Math.max(0, values.roughness));
                if (values.hasOwnProperty('_metalness'))
                    materialData.metalness = Math.min(1, Math.max(0, values.metalness));
            }
            return materialData;
        });
    }
    loadMesh(meshName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.meshes[meshName])
                throw new viewer_shared_services_1.SDError('Mesh not available.');
            const mesh = this._content.meshes[meshName];
            const meshNode = new viewer_shared_node_tree_1.TreeNode(meshName);
            if (!mesh.primitives)
                return new viewer_shared_node_tree_1.TreeNode('primitive');
            for (let i = 0, len = mesh.primitives.length; i < len; i++) {
                const primitiveNode = new viewer_shared_node_tree_1.TreeNode('primitive_' + i);
                meshNode.addChild(primitiveNode);
                let primitive = mesh.primitives[i];
                const attributes = {};
                for (let attribute in primitive.attributes) {
                    attributes[attribute] = yield this.loadAccessor(primitive.attributes[attribute]);
                    if (attribute === 'COLOR')
                        attributes[attribute] = new viewer_shared_types_1.AttributeData(attributes[attribute].array, attributes[attribute].itemSize, attributes[attribute].itemBytes, attributes[attribute].byteOffset, attributes[attribute].elementBytes, true, attributes[attribute].count, [], [], attributes[attribute].byteStride);
                }
                let material;
                if (primitive.material) {
                    material = yield this.loadMaterial(primitive.material);
                }
                else {
                    material = new viewer_shared_types_1.MaterialData({ roughness: 1, metalness: 0 });
                }
                const geometry = new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, 4, yield this.loadAccessor(primitive.indices), material));
                primitiveNode.data.push(geometry);
            }
            return meshNode;
        });
    }
    loadNode(nodeName) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.nodes[nodeName])
                throw new viewer_shared_services_1.SDError('Node not available.');
            const node = this._content.nodes[nodeName];
            const nodeDef = new viewer_shared_node_tree_1.TreeNode(nodeName);
            if (node.matrix) {
                nodeDef.transformations.push({
                    id: this._uuidGenerator.create(),
                    matrix: gl_matrix_1.mat4.fromValues(node.matrix[0], node.matrix[1], node.matrix[2], node.matrix[3], node.matrix[4], node.matrix[5], node.matrix[6], node.matrix[7], node.matrix[8], node.matrix[9], node.matrix[10], node.matrix[11], node.matrix[12], node.matrix[13], node.matrix[14], node.matrix[15])
                });
            }
            else if (node.translation || node.scale || node.rotation) {
                const matT = node.translation ? gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(node.translation[0], node.translation[1], node.translation[2])) : gl_matrix_1.mat4.create();
                const matS = node.scale ? gl_matrix_1.mat4.fromScaling(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(node.scale[0], node.scale[1], node.scale[2])) : gl_matrix_1.mat4.create();
                const matR = node.rotation ? gl_matrix_1.mat4.fromQuat(gl_matrix_1.mat4.create(), gl_matrix_1.vec4.fromValues(node.rotation[0], node.rotation[1], node.rotation[2], node.rotation[3])) : gl_matrix_1.mat4.create();
                const matrix = gl_matrix_1.mat4.mul(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.mul(gl_matrix_1.mat4.create(), matT, matS), matR);
                nodeDef.transformations.push({
                    id: this._uuidGenerator.create(),
                    matrix: matrix
                });
            }
            if (node.meshes) {
                for (let i = 0, len = node.meshes.length; i < len; i++) {
                    nodeDef.addChild(yield this.loadMesh(node.meshes[i]));
                }
            }
            if (node.children) {
                for (let i = 0, len = node.children.length; i < len; i++) {
                    nodeDef.addChild(yield this.loadNode(node.children[i]));
                }
            }
            return nodeDef;
        });
    }
    loadScene() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.scene)
                throw new viewer_shared_services_1.SDError('No scene.');
            if (!this._content.scenes[this._content.scene])
                throw new viewer_shared_services_1.SDError('Scene not available.');
            const scene = this._content.scenes[this._content.scene];
            const sceneDef = new viewer_shared_node_tree_1.TreeNode(this._content.scene);
            if (this._content.asset && ((_a = this._content.asset) === null || _a === void 0 ? void 0 : _a.generator) !== "ShapeDiverGltfWriter" && ((_b = this._content.asset) === null || _b === void 0 ? void 0 : _b.generator) !== "ShapeDiverGltfV1Writer") {
                sceneDef.transformations.push({
                    id: this._uuidGenerator.create(),
                    matrix: this._globalTransformation
                });
            }
            if (scene.nodes)
                for (let i = 0, len = scene.nodes.length; i < len; i++)
                    sceneDef.addChild(yield this.loadNode(scene.nodes[i]));
            return sceneDef;
        });
    }
}
exports.GLTFLoader = GLTFLoader;
//# sourceMappingURL=GLTFLoader.js.map