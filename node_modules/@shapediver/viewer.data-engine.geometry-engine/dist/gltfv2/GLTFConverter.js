"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GLTFConverter = exports.GLTF_EXTENSIONS = void 0;
const viewer_shared_build_data_1 = require("@shapediver/viewer.shared.build-data");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const tsyringe_1 = require("tsyringe");
const viewer_data_engine_shared_types_1 = require("@shapediver/viewer.data-engine.shared-types");
const gl_matrix_1 = require("gl-matrix");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
var GLTF_EXTENSIONS;
(function (GLTF_EXTENSIONS) {
    GLTF_EXTENSIONS["KHR_BINARY_GLTF"] = "KHR_binary_glTF";
    GLTF_EXTENSIONS["KHR_MATERIALS_PBRSPECULARGLOSSINESS"] = "KHR_materials_pbrSpecularGlossiness";
    GLTF_EXTENSIONS["KHR_MATERIALS_UNLIT"] = "KHR_materials_unlit";
})(GLTF_EXTENSIONS = exports.GLTF_EXTENSIONS || (exports.GLTF_EXTENSIONS = {}));
class GLTFConverter {
    constructor() {
        this.BINARY_EXTENSION_HEADER_LENGTH = 20;
        this._converter = tsyringe_1.container.resolve(viewer_shared_services_1.Converter);
        this._globalTransformation = gl_matrix_1.mat4.fromValues(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1);
        this._globalTransformationInverse = gl_matrix_1.mat4.fromValues(1, 0, 0, 0, 0, 0, -1, 0, 0, 1, 0, 0, 0, 0, 0, 1);
        this._httpClient = tsyringe_1.container.resolve(viewer_shared_services_1.HttpClient);
        this._imageLoader = tsyringe_1.container.resolve(viewer_shared_services_1.ImageLoader);
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
        this._uuidGenerator = tsyringe_1.container.resolve(viewer_shared_services_1.UuidGenerator);
        this._buffers = [];
        this._byteOffset = 0;
        this._content = {
            asset: {
                copyright: '2021 (c) ShapeDiver',
                generator: 'ShapeDiverViewer@' + viewer_shared_build_data_1.build_data.build_version,
                version: '2.0',
                extensions: {}
            },
        };
        this._extensionsRequired = [];
        this._extensionsUsed = [];
        this._imageCache = {};
        this._loaded = {};
        this._promises = [];
    }
    convert(node) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const sceneNode = new viewer_shared_node_tree_1.TreeNode('ShapeDiverRootNode');
            sceneNode.addChild(node);
            const sceneDef = {
                name: sceneNode.name,
                nodes: []
            };
            const globalTransformationInverseID = this._uuidGenerator.create();
            node.transformations.push({
                id: globalTransformationInverseID,
                matrix: this._globalTransformationInverse,
            });
            (_a = sceneDef.nodes) === null || _a === void 0 ? void 0 : _a.push(this.convertNode(node));
            for (let i = 0; i < node.transformations.length; i++)
                if (node.transformations[i].id === globalTransformationInverseID)
                    node.transformations.splice(i, 1);
            this._content.scenes = [];
            this._content.scenes.push(sceneDef);
            const extensionsUsedList = Object.keys(this._extensionsUsed);
            if (extensionsUsedList.length > 0)
                this._content.extensionsUsed = extensionsUsedList;
            const extensionsRequiredList = Object.keys(this._extensionsRequired);
            if (extensionsRequiredList.length > 0)
                this._content.extensionsRequired = extensionsRequiredList;
            yield Promise.all(this._promises);
            const blob = new Blob(this._buffers, { type: 'application/octet-stream' });
            if (this._content.buffers && this._content.buffers.length > 0)
                this._content.buffers[0].byteLength = blob.size;
            return new Promise(resolve => {
                const reader = new window.FileReader();
                reader.readAsArrayBuffer(blob);
                reader.onloadend = () => {
                    const binaryChunk = this.getPaddedArrayBuffer(reader.result);
                    const binaryChunkPrefix = new DataView(new ArrayBuffer(8));
                    binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);
                    binaryChunkPrefix.setUint32(4, 0x004E4942, true);
                    const jsonChunk = this.getPaddedArrayBuffer(this.stringToArrayBuffer(JSON.stringify(this._content)), 0x20);
                    const jsonChunkPrefix = new DataView(new ArrayBuffer(8));
                    jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);
                    jsonChunkPrefix.setUint32(4, 0x4E4F534A, true);
                    const header = new ArrayBuffer(12);
                    const headerView = new DataView(header);
                    headerView.setUint32(0, 0x46546C67, true);
                    headerView.setUint32(4, 2, true);
                    const totalByteLength = 12
                        + jsonChunkPrefix.byteLength + jsonChunk.byteLength
                        + binaryChunkPrefix.byteLength + binaryChunk.byteLength;
                    headerView.setUint32(8, totalByteLength, true);
                    const glbBlob = new Blob([
                        header,
                        jsonChunkPrefix,
                        jsonChunk,
                        binaryChunkPrefix,
                        binaryChunk
                    ], { type: 'application/octet-stream' });
                    const glbReader = new window.FileReader();
                    glbReader.readAsArrayBuffer(glbBlob);
                    glbReader.onloadend = () => {
                        resolve(glbReader.result);
                    };
                };
            });
        });
    }
    convertAccessor(data) {
        if (!this._content.accessors)
            this._content.accessors = [];
        const bufferView = this.convertBufferView(data);
        const minMax = this.getMinMax(data);
        const accessorDef = {
            bufferView: bufferView,
            byteOffset: 0,
            componentType: this.getComponentType(data.array),
            normalized: data.normalized,
            count: +data.count,
            max: minMax.max,
            min: minMax.min,
            type: this.getType(data.itemSize),
        };
        this._content.accessors.push(accessorDef);
        return this._content.accessors.length - 1;
    }
    convertBuffer(buffer) {
        if (!this._content.buffers)
            this._content.buffers = [];
        if (this._content.buffers.length === 0)
            this._content.buffers = [{ byteLength: 0 }];
        this._buffers.push(buffer);
        return 0;
    }
    convertBufferView(data) {
        if (!this._content.bufferViews)
            this._content.bufferViews = [];
        let componentTypeNumber = this.getComponentType(data.array);
        let componentSize = viewer_data_engine_shared_types_1.ACCESSORCOMPONENTSIZE_V2[componentTypeNumber];
        const byteLength = Math.ceil(data.count * data.itemSize * componentSize / 4) * 4;
        const dataView = new DataView(new ArrayBuffer(byteLength));
        let offset = 0;
        for (let i = 0; i < data.count; i++) {
            for (let a = 0; a < data.itemSize; a++) {
                let value = 0;
                if (data.itemSize > 4) {
                    value = data.array[i * data.itemSize + a];
                }
                else {
                    if (a === 0)
                        value = data.array[i * data.itemSize];
                    else if (a === 1)
                        value = data.array[i * data.itemSize + 1];
                    else if (a === 2)
                        value = data.array[i * data.itemSize + 2];
                    else if (a === 3)
                        value = data.array[i * data.itemSize + 3];
                }
                if (data.array instanceof Float32Array) {
                    dataView.setFloat32(offset, value, true);
                }
                else if (data.array instanceof Uint32Array) {
                    dataView.setUint32(offset, value, true);
                }
                else if (data.array instanceof Uint16Array) {
                    dataView.setUint16(offset, value, true);
                }
                else if (data.array instanceof Int16Array) {
                    dataView.setInt16(offset, value, true);
                }
                else if (data.array instanceof Uint8Array) {
                    dataView.setUint8(offset, value);
                }
                else if (data.array instanceof Int8Array) {
                    dataView.setInt8(offset, value);
                }
                offset += componentSize;
            }
        }
        const bufferViewDef = {
            buffer: this.convertBuffer(dataView.buffer),
            byteOffset: this._byteOffset,
            byteLength: byteLength
        };
        this._byteOffset += byteLength;
        this._content.bufferViews.push(bufferViewDef);
        return this._content.bufferViews.length - 1;
    }
    convertBufferViewImage(blob) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.bufferViews)
                this._content.bufferViews = [];
            return new Promise((resolve) => {
                const reader = new window.FileReader();
                reader.readAsArrayBuffer(blob);
                reader.onloadend = () => {
                    const buffer = this.getPaddedArrayBuffer(reader.result);
                    const bufferViewDef = {
                        buffer: this.convertBuffer(buffer),
                        byteOffset: this._byteOffset,
                        byteLength: buffer.byteLength
                    };
                    this._byteOffset += buffer.byteLength;
                    this._content.bufferViews.push(bufferViewDef);
                    resolve(this._content.bufferViews.length - 1);
                };
            });
        });
    }
    convertImage(data) {
        if (!this._content.images)
            this._content.images = [];
        if (this._imageCache[data.image.src])
            return this._imageCache[data.image.src];
        const imageDef = {};
        const canvas = document.createElement('canvas');
        canvas.width = data.image.width;
        canvas.height = data.image.height;
        const ctx = canvas.getContext('2d');
        if (data.flipY === true) {
            ctx.translate(0, canvas.height);
            ctx.scale(1, -1);
        }
        let mimeType = 'image/png';
        if (data.image.src.endsWith('.jpg') || data.image.src.includes('image/jpeg'))
            mimeType = 'image/jpeg';
        imageDef.mimeType = mimeType;
        const DATA_URI_REGEX = /^data:(.*?)(;base64)?,(.*)$/;
        if (DATA_URI_REGEX.test(data.image.src)) {
            const byteString = atob(data.image.src.split(',')[1]);
            const mimeType = data.image.src.split(',')[0].split(':')[1].split(';')[0];
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            for (let i = 0; i < byteString.length; i++)
                ia[i] = byteString.charCodeAt(i);
            const blob = new Blob([ab], { type: mimeType });
            this._promises.push(new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                const bufferViewIndex = yield this.convertBufferViewImage(blob);
                imageDef.bufferView = bufferViewIndex;
                resolve();
            })));
        }
        else {
            ctx.drawImage(data.image, 0, 0, canvas.width, canvas.height);
            this._promises.push(new Promise((resolve) => {
                canvas.toBlob((blob) => __awaiter(this, void 0, void 0, function* () {
                    const bufferViewIndex = yield this.convertBufferViewImage(blob);
                    imageDef.bufferView = bufferViewIndex;
                    resolve();
                }), mimeType);
            }));
        }
        this._content.images.push(imageDef);
        this._imageCache[data.image.src] = this._content.images.length - 1;
        return this._content.images.length - 1;
    }
    convertMaterial(data) {
        var _a, _b;
        if (!this._content.materials)
            this._content.materials = [];
        const materialDef = {
            name: data.id,
            pbrMetallicRoughness: {}
        };
        if (data.KHR_materials_pbrSpecularGlossiness) {
            if (!this._extensionsUsed.includes('KHR_materials_pbrSpecularGlossiness'))
                this._extensionsUsed.push('KHR_materials_pbrSpecularGlossiness');
            if (!this._extensionsRequired.includes('KHR_materials_pbrSpecularGlossiness'))
                this._extensionsRequired.push('KHR_materials_pbrSpecularGlossiness');
            const ext = {};
            ext.diffuseFactor = this._converter.toColorArray(data.color);
            ext.diffuseFactor[3] = data.opacity;
            if (data.map)
                ext.diffuseTexture = { index: this.convertTexture(data.map) };
            ext.specularFactor = this._converter.toColorArray(data.specular);
            ext.glossinessFactor = data.glossiness;
            if (data.specularGlossinessMap)
                ext.specularGlossinessTexture = { index: this.convertTexture(data.specularGlossinessMap) };
            materialDef.extensions = {
                KHR_materials_pbrSpecularGlossiness: ext
            };
        }
        else if (data.KHR_materials_unlit) {
            if (!this._extensionsUsed.includes('KHR_materials_unlit'))
                this._extensionsUsed.push('KHR_materials_unlit');
            if (!this._extensionsRequired.includes('KHR_materials_unlit'))
                this._extensionsRequired.push('KHR_materials_unlit');
            materialDef.pbrMetallicRoughness.baseColorFactor = this._converter.toColorArray(data.color);
            materialDef.pbrMetallicRoughness.baseColorFactor[3] = data.opacity;
            if (data.map)
                materialDef.pbrMetallicRoughness.baseColorTexture = { index: this.convertTexture(data.map) };
            materialDef.extensions = {
                KHR_materials_unlit: {}
            };
        }
        else {
            materialDef.pbrMetallicRoughness.baseColorFactor = this._converter.toColorArray(data.color);
            materialDef.pbrMetallicRoughness.baseColorFactor[3] = data.opacity;
            if (data.map)
                materialDef.pbrMetallicRoughness.baseColorTexture = { index: this.convertTexture(data.map) };
            materialDef.pbrMetallicRoughness.metallicFactor = data.metalness;
            materialDef.pbrMetallicRoughness.roughnessFactor = data.roughness;
            if (data.metalnessRoughnessMap) {
                materialDef.pbrMetallicRoughness.metallicRoughnessTexture = { index: this.convertTexture(data.metalnessRoughnessMap) };
            }
            else if (data.metalnessMap || data.roughnessMap) {
                const map = (data.metalnessMap || data.roughnessMap);
                const combinedImage = this._converter.combineImages(undefined, (_a = data.roughnessMap) === null || _a === void 0 ? void 0 : _a.image, (_b = data.metalnessMap) === null || _b === void 0 ? void 0 : _b.image);
                materialDef.pbrMetallicRoughness.metallicRoughnessTexture = { index: this.convertTexture(new viewer_shared_types_1.MapData(combinedImage, map.wrapS, map.wrapT, map.minFilter, map.magFilter, map.center, map.color, map.offset, map.repeat, map.rotation, map.flipY)) };
            }
        }
        if (data.normalMap)
            materialDef.normalTexture = { index: this.convertTexture(data.normalMap) };
        if (data.aoMap)
            materialDef.occlusionTexture = { index: this.convertTexture(data.aoMap) };
        if (data.emissiveMap)
            materialDef.emissiveTexture = { index: this.convertTexture(data.emissiveMap) };
        if (data.emissiveness)
            materialDef.emissiveFactor = this._converter.toColorArray(data.emissiveness);
        materialDef.alphaMode = data.alphaMode.toUpperCase();
        if (data.alphaMode === viewer_shared_types_1.MATERIAL_ALPHA.MASK)
            materialDef.alphaCutoff = data.alphaCutoff;
        materialDef.doubleSided = data.side === viewer_shared_types_1.MATERIAL_SIDE.DOUBLE;
        this._content.materials.push(materialDef);
        return this._content.materials.length - 1;
    }
    convertMesh(data) {
        var _a;
        if (!this._content.meshes)
            this._content.meshes = [];
        const meshDef = {
            primitives: [],
            name: data.id
        };
        (_a = meshDef.primitives) === null || _a === void 0 ? void 0 : _a.push(this.convertPrimitive(data.primitive));
        this._content.meshes.push(meshDef);
        return this._content.meshes.length - 1;
    }
    convertNode(node) {
        var _a;
        if (!this._content.nodes)
            this._content.nodes = [];
        const nodeDef = {
            name: node.name,
        };
        if (node.transformations.length > 0)
            nodeDef.matrix = [node.nodeMatrix[0], node.nodeMatrix[1], node.nodeMatrix[2], node.nodeMatrix[3],
                node.nodeMatrix[4], node.nodeMatrix[5], node.nodeMatrix[6], node.nodeMatrix[7],
                node.nodeMatrix[8], node.nodeMatrix[9], node.nodeMatrix[10], node.nodeMatrix[11],
                node.nodeMatrix[12], node.nodeMatrix[13], node.nodeMatrix[14], node.nodeMatrix[15]];
        for (let i = 0; i < node.data.length; i++)
            if (node.data[i] instanceof viewer_shared_types_1.GeometryData)
                nodeDef.mesh = this.convertMesh(node.data[i]);
        if (node.children.length > 0)
            nodeDef.children = [];
        for (let i = 0; i < node.children.length; i++)
            (_a = nodeDef.children) === null || _a === void 0 ? void 0 : _a.push(this.convertNode(node.children[i]));
        this._content.nodes.push(nodeDef);
        return this._content.nodes.length - 1;
    }
    convertPrimitive(data) {
        const primitiveDef = {
            attributes: {},
            mode: data.mode
        };
        for (let a in data.attributes)
            primitiveDef.attributes[a] = this.convertAccessor(data.attributes[a]);
        if (data.indices)
            primitiveDef.indices = this.convertAccessor(data.indices);
        if (data.material)
            primitiveDef.material = this.convertMaterial(data.material);
        return primitiveDef;
    }
    convertTexture(data) {
        if (!this._content.textures)
            this._content.textures = [];
        const textureDef = {
            source: this.convertImage(data)
        };
        this._content.textures.push(textureDef);
        return this._content.textures.length - 1;
    }
    getComponentType(array) {
        switch (true) {
            case array instanceof Int8Array:
                return 5120;
            case array instanceof Uint8Array:
                return 5121;
            case array instanceof Int16Array:
                return 5122;
            case array instanceof Uint16Array:
                return 5123;
            case array instanceof Uint32Array:
                return 5125;
            default:
                return 5126;
        }
    }
    getMinMax(data) {
        const output = {
            min: new Array(data.itemSize).fill(Number.POSITIVE_INFINITY),
            max: new Array(data.itemSize).fill(Number.NEGATIVE_INFINITY)
        };
        for (let i = 0; i < data.count; i++) {
            for (let a = 0; a < data.itemSize; a++) {
                let value = 0;
                if (data.itemSize > 4) {
                    value = data.array[i * data.itemSize + a];
                }
                else {
                    if (a === 0)
                        value = data.array[i * data.itemSize];
                    else if (a === 1)
                        value = data.array[i * data.itemSize + 1];
                    else if (a === 2)
                        value = data.array[i * data.itemSize + 2];
                    else if (a === 3)
                        value = data.array[i * data.itemSize + 3];
                }
                output.min[a] = Math.min(output.min[a], value);
                output.max[a] = Math.max(output.max[a], value);
            }
        }
        return output;
    }
    getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {
        const paddedLength = Math.ceil(arrayBuffer.byteLength / 4) * 4;
        if (paddedLength !== arrayBuffer.byteLength) {
            const array = new Uint8Array(paddedLength);
            array.set(new Uint8Array(arrayBuffer));
            if (paddingByte !== 0) {
                for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {
                    array[i] = paddingByte;
                }
            }
            return array.buffer;
        }
        return arrayBuffer;
    }
    getType(itemSize) {
        switch (itemSize) {
            case 1:
                return 'SCALAR';
            case 2:
                return 'VEC2';
            case 3:
                return 'VEC3';
            case 4:
                return 'VEC4';
            case 9:
                return 'MAT3';
            case 18:
                return 'MAT4';
            default:
                return 'VEC3';
        }
    }
    stringToArrayBuffer(text) {
        if (window.TextEncoder !== undefined) {
            return new TextEncoder().encode(text).buffer;
        }
        const array = new Uint8Array(new ArrayBuffer(text.length));
        for (let i = 0, il = text.length; i < il; i++) {
            const value = text.charCodeAt(i);
            array[i] = value > 0xFF ? 0x20 : value;
        }
        return array.buffer;
    }
}
exports.GLTFConverter = GLTFConverter;
//# sourceMappingURL=GLTFConverter.js.map