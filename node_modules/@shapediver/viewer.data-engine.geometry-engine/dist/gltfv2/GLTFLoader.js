"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GLTFLoader = exports.GLTF_EXTENSIONS = void 0;
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const tsyringe_1 = require("tsyringe");
const viewer_data_engine_shared_types_1 = require("@shapediver/viewer.data-engine.shared-types");
const gl_matrix_1 = require("gl-matrix");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
var GLTF_EXTENSIONS;
(function (GLTF_EXTENSIONS) {
    GLTF_EXTENSIONS["KHR_BINARY_GLTF"] = "KHR_binary_glTF";
    GLTF_EXTENSIONS["KHR_MATERIALS_PBRSPECULARGLOSSINESS"] = "KHR_materials_pbrSpecularGlossiness";
    GLTF_EXTENSIONS["KHR_MATERIALS_UNLIT"] = "KHR_materials_unlit";
})(GLTF_EXTENSIONS = exports.GLTF_EXTENSIONS || (exports.GLTF_EXTENSIONS = {}));
class GLTFLoader {
    constructor() {
        this.BINARY_EXTENSION_HEADER_LENGTH = 20;
        this._httpClient = tsyringe_1.container.resolve(viewer_shared_services_1.HttpClient);
        this._imageLoader = tsyringe_1.container.resolve(viewer_shared_services_1.ImageLoader);
        this._uuidGenerator = tsyringe_1.container.resolve(viewer_shared_services_1.UuidGenerator);
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
        this._globalTransformation = gl_matrix_1.mat4.fromValues(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1);
        this._converter = tsyringe_1.container.resolve(viewer_shared_services_1.Converter);
        this._performanceEvaluator = tsyringe_1.container.resolve(viewer_shared_services_1.PerformanceEvaluator);
        this._loaded = {};
        this._nodes = {};
    }
    load(content, gltfBinary, gltfHeader, baseUri) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this._baseUri = baseUri;
            if (gltfBinary && gltfHeader)
                this._body = gltfBinary.slice(this.BINARY_EXTENSION_HEADER_LENGTH + gltfHeader.contentLength + 8, gltfHeader.length);
            this._content = content;
            try {
                this.validateVersionAndExtensions();
                const node = yield this.loadScene();
                if (this._content.animations)
                    for (let i = 0; i < ((_a = this._content.animations) === null || _a === void 0 ? void 0 : _a.length); i++)
                        node.data.push(yield this.loadAnimation(i));
                return node;
            }
            catch (e) {
                if (e.response && e.response.status) {
                    this._logger.httpError(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, e, `GLTFLoader.load: Loading of geometry failed. ${e.message}`, e.response.status, false);
                }
                else {
                    this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, e, `GLTFLoader.load: Loading of geometry failed. ${e.message}`, false);
                }
                return new viewer_shared_node_tree_1.TreeNode();
            }
        });
    }
    loadWithUrl(url) {
        return __awaiter(this, void 0, void 0, function* () {
            this._performanceEvaluator.startSection('gltfProcessing.' + url);
            let axiosResponse;
            try {
                this._performanceEvaluator.startSection('loadGltf.' + url);
                axiosResponse = yield this._httpClient.get(url, {
                    responseType: 'arraybuffer'
                });
                this._performanceEvaluator.endSection('loadGltf.' + url);
            }
            catch (e) {
                if (e.response && e.response.status) {
                    this._logger.httpError(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, e, `GLTFLoader.load: Initial loading of geometry failed.`, e.response.status, false);
                }
                else {
                    this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, e, `GLTFLoader.load: Initial loading of geometry failed.`, false);
                }
                return new viewer_shared_node_tree_1.TreeNode();
            }
            const magic = new TextDecoder().decode(new Uint8Array(axiosResponse.data, 0, 4));
            const isBinary = magic === 'glTF' || (axiosResponse.headers['content-type'] &&
                (axiosResponse.headers['content-type'] === 'model/gltf-binary' ||
                    axiosResponse.headers['content-type'] === 'application/octet-stream' ||
                    axiosResponse.headers['content-type'] === 'model/gltf.binary'));
            if (isBinary) {
                const binaryGeometry = axiosResponse.data;
                const headerDataView = new DataView(binaryGeometry, 0, this.BINARY_EXTENSION_HEADER_LENGTH);
                const header = {
                    magic: magic,
                    version: headerDataView.getUint32(4, true),
                    length: headerDataView.getUint32(8, true),
                    contentLength: headerDataView.getUint32(12, true),
                    contentFormat: headerDataView.getUint32(16, true)
                };
                if (header.magic != 'glTF') {
                    this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, new viewer_shared_services_1.SDError('GLTFLoader.load: Invalid data: glTF magic wrong.'));
                    return new viewer_shared_node_tree_1.TreeNode();
                }
                const contentDataView = new DataView(binaryGeometry, this.BINARY_EXTENSION_HEADER_LENGTH, header.contentLength);
                const contentDecoded = new TextDecoder().decode(contentDataView);
                this._content = JSON.parse(contentDecoded);
                this._body = binaryGeometry.slice(this.BINARY_EXTENSION_HEADER_LENGTH + header.contentLength + 8, header.length);
            }
            else {
                this._content = JSON.parse(new TextDecoder().decode(axiosResponse.data));
                const removeLastDirectoryPartOf = (the_url) => {
                    const dir_char = the_url.includes("/") ? "/" : "\\";
                    const the_arr = the_url.split(dir_char);
                    the_arr.pop();
                    return the_arr.join(dir_char);
                };
                this._baseUri = removeLastDirectoryPartOf(url);
                if (!this._baseUri && window && window.location && window.location.href)
                    this._baseUri = removeLastDirectoryPartOf(window.location.href);
            }
            try {
                this.validateVersionAndExtensions();
                const node = yield this.loadScene();
                this._performanceEvaluator.endSection('gltfProcessing.' + url);
                return node;
            }
            catch (e) {
                if (e.response && e.response.status) {
                    this._logger.httpError(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, e, `GLTFLoader.load: Loading of geometry failed. ${e.message}`, e.response.status, false);
                }
                else {
                    this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, e, `GLTFLoader.load: Loading of geometry failed. ${e.message}`, false);
                }
                return new viewer_shared_node_tree_1.TreeNode();
            }
        });
    }
    loadAccessor(accessorId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.accessors)
                throw new viewer_shared_services_1.SDError('Accessors not available.');
            if (!this._content.accessors[accessorId])
                throw new viewer_shared_services_1.SDError('Accessor not available.');
            const accessor = this._content.accessors[accessorId];
            if (this._loaded['accessor'] && this._loaded['accessor'][accessorId])
                return this._loaded['accessor'][accessorId];
            if (accessor.bufferView === undefined) {
                return Promise.resolve(null);
            }
            const arrayBuffer = yield this.loadBufferView(accessor.bufferView);
            const itemSize = viewer_data_engine_shared_types_1.ACCESSORTYPE_V2[accessor.type];
            if (accessor.componentType === 5124)
                this._logger.warn(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, 'GLTFLoader.loadAccessor: The componentType for this accessor is 5124, which is not allowed. Trying to load it anyway.');
            const ArrayType = viewer_data_engine_shared_types_1.ACCESSORCOMPONENTTYPE_V2[accessor.componentType];
            const elementBytes = ArrayType.BYTES_PER_ELEMENT;
            const itemBytes = elementBytes * itemSize;
            const byteOffset = accessor.byteOffset || 0;
            const byteStride = accessor.bufferView !== undefined ? this._content.bufferViews ? this._content.bufferViews[accessor.bufferView].byteStride : undefined : undefined;
            const normalized = accessor.normalized === true;
            let array;
            if (byteStride && byteStride !== itemBytes) {
                const ibSlice = Math.floor(byteOffset / byteStride);
                array = new ArrayType(arrayBuffer, ibSlice * byteStride, accessor.count * byteStride / elementBytes);
            }
            else {
                if (arrayBuffer === null) {
                    array = new ArrayType(accessor.count * itemSize);
                }
                else {
                    array = new ArrayType(arrayBuffer, byteOffset, accessor.count * itemSize);
                }
            }
            if (accessor.sparse !== undefined) {
                const itemSizeIndices = viewer_data_engine_shared_types_1.ACCESSORTYPE_V2.SCALAR;
                const IndicesArrayType = viewer_data_engine_shared_types_1.ACCESSORCOMPONENTTYPE_V2[accessor.sparse.indices.componentType];
                const byteOffsetIndices = accessor.sparse.indices.byteOffset || 0;
                const byteOffsetValues = accessor.sparse.values.byteOffset || 0;
                if (!accessor.sparse.indices.bufferView || !accessor.sparse.values.bufferView)
                    throw new viewer_shared_services_1.SDError('Sparse Mesh not properly defined.');
                const sparseIndices = new IndicesArrayType(yield this.loadBufferView(accessor.sparse.indices.bufferView), byteOffsetIndices, accessor.sparse.count * itemSizeIndices);
                const sparseValues = new ArrayType(yield this.loadBufferView(accessor.sparse.values.bufferView), byteOffsetValues, accessor.sparse.count * itemSize);
                if (!this._loaded['accessor'])
                    this._loaded['accessor'] = {};
                this._loaded['accessor'][accessorId] = new viewer_shared_types_1.AttributeData(array, itemSize, itemBytes, byteOffset, elementBytes, normalized, accessor.count, accessor.min, accessor.max, byteStride, true, sparseIndices, sparseValues);
                return this._loaded['accessor'][accessorId];
            }
            if (!this._loaded['accessor'])
                this._loaded['accessor'] = {};
            this._loaded['accessor'][accessorId] = new viewer_shared_types_1.AttributeData(array, itemSize, itemBytes, byteOffset, elementBytes, normalized, accessor.count, accessor.min, accessor.max, byteStride);
            return this._loaded['accessor'][accessorId];
        });
    }
    loadBuffer(bufferId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.buffers)
                throw new viewer_shared_services_1.SDError('Buffers not available.');
            if (!this._content.buffers[bufferId])
                throw new viewer_shared_services_1.SDError('Buffer not available.');
            const buffer = this._content.buffers[bufferId];
            if (this._loaded['buffer'] && this._loaded['buffer'][bufferId])
                return this._loaded['buffer'][bufferId];
            if (buffer.type && buffer.type !== 'arraybuffer') {
                throw new viewer_shared_services_1.SDError(`GLTFLoader.loadBuffer: ${buffer.type} is not supported.`);
            }
            if (buffer.uri === undefined && bufferId === 0) {
                if (!this._body)
                    throw new viewer_shared_services_1.SDError(`GLTFLoader.loadBuffer: Buffer not available.`);
                return Promise.resolve(this._body);
            }
            const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
            const dataUriRegexResult = buffer.uri.match(dataUriRegex);
            let result;
            if (dataUriRegexResult) {
                const isBase64 = !!dataUriRegexResult[2];
                let data = dataUriRegexResult[3];
                data = decodeURIComponent(data);
                if (isBase64)
                    data = atob(data);
                const view = new Uint8Array(data.length);
                for (let i = 0; i < data.length; i++) {
                    view[i] = data.charCodeAt(i);
                }
                result = view.buffer;
            }
            else {
                let httpResult = yield this._httpClient.get(this._baseUri + '/' + buffer.uri, {
                    responseType: 'arraybuffer'
                });
                result = (httpResult.data);
            }
            if (!this._loaded['buffer'])
                this._loaded['buffer'] = {};
            this._loaded['buffer'][bufferId] = result;
            return this._loaded['buffer'][bufferId];
        });
    }
    loadBufferView(bufferViewId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.bufferViews)
                throw new viewer_shared_services_1.SDError('BufferViews not available.');
            if (!this._content.bufferViews[bufferViewId])
                throw new viewer_shared_services_1.SDError('BufferView not available.');
            const bufferView = this._content.bufferViews[bufferViewId];
            if (this._loaded['bufferView'] && this._loaded['bufferView'][bufferViewId])
                return this._loaded['bufferView'][bufferViewId];
            const byteLength = bufferView.byteLength || 0;
            const byteOffset = bufferView.byteOffset || 0;
            if (bufferView.buffer === undefined)
                throw new viewer_shared_services_1.SDError('BufferView has no buffer defined.');
            const buffer = yield this.loadBuffer(bufferView.buffer);
            const result = buffer.slice(byteOffset, byteOffset + byteLength);
            if (!this._loaded['bufferView'])
                this._loaded['bufferView'] = {};
            this._loaded['bufferView'][bufferViewId] = result;
            return this._loaded['bufferView'][bufferViewId];
        });
    }
    loadMap(textureId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.textures)
                throw new viewer_shared_services_1.SDError('Textures not available.');
            const texture = this._content.textures[textureId];
            if (this._loaded['texture'] && this._loaded['texture'][textureId])
                return this._loaded['texture'][textureId].clone();
            if (!this._content.images)
                throw new viewer_shared_services_1.SDError('Images not available.');
            const image = this._content.images[texture.source];
            const sampler = this._content.samplers && texture.sampler && this._content.samplers[texture.sampler] ? this._content.samplers[texture.sampler] : {};
            const DATA_URI_REGEX = /^data:(.*?)(;base64)?,(.*)$/;
            const HTTPS_URI_REGEX = /^https:\/\//;
            let mapData;
            if (image.bufferView !== undefined) {
                const bufferView = yield this.loadBufferView(image.bufferView);
                const dataView = new DataView(bufferView);
                const array = [];
                for (let i = 0; i < dataView.byteLength; i += 1)
                    array[i] = dataView.getUint8(i);
                const blob = new Blob([new Uint8Array(array)], { type: image.mimeType });
                const dataUri = window.URL.createObjectURL(blob);
                mapData = new viewer_shared_types_1.MapData(yield this._imageLoader.load(dataUri), sampler.wrapS, sampler.wrapT, sampler.minFilter, sampler.magFilter, undefined, undefined, undefined, undefined, undefined, false);
            }
            else {
                const url = DATA_URI_REGEX.test(image.uri) || HTTPS_URI_REGEX.test(image.uri) ? image.uri : `${this._baseUri}/${image.uri}`;
                mapData = new viewer_shared_types_1.MapData(yield this._imageLoader.load(url), sampler.wrapS, sampler.wrapT, sampler.minFilter, sampler.magFilter, undefined, undefined, undefined, undefined, undefined, false);
            }
            if (!this._loaded['texture'])
                this._loaded['texture'] = {};
            this._loaded['texture'][textureId] = mapData;
            return this._loaded['texture'][textureId].clone();
        });
    }
    loadMaterial(materialId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.materials)
                throw new viewer_shared_services_1.SDError('Materials not available.');
            const material = this._content.materials[materialId];
            const materialData = new viewer_shared_types_1.MaterialData();
            if (material.name !== undefined)
                materialData.name = material.name;
            if (material.extensions && material.extensions.KHR_materials_pbrSpecularGlossiness) {
                const pbrSpecularGlossiness = material.extensions.KHR_materials_pbrSpecularGlossiness;
                materialData.KHR_materials_pbrSpecularGlossiness = true;
                materialData.color = '#ffffff';
                materialData.opacity = 1.0;
                if (pbrSpecularGlossiness.diffuseFactor !== undefined) {
                    materialData.color = this._converter.toColor([pbrSpecularGlossiness.diffuseFactor[0] * 255, pbrSpecularGlossiness.diffuseFactor[1] * 255, pbrSpecularGlossiness.diffuseFactor[2] * 255]);
                    materialData.opacity = pbrSpecularGlossiness.diffuseFactor[3];
                }
                if (pbrSpecularGlossiness.diffuseTexture !== undefined)
                    materialData.map = yield this.loadMap(pbrSpecularGlossiness.diffuseTexture.index);
                materialData.emissiveness = '#000000';
                materialData.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
                materialData.specular = '#ffffff';
                if (pbrSpecularGlossiness.specularFactor !== undefined) {
                    materialData.specular = this._converter.toColor([pbrSpecularGlossiness.specularFactor[0] * 255, pbrSpecularGlossiness.specularFactor[1] * 255, pbrSpecularGlossiness.specularFactor[2] * 255]);
                }
                if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {
                    materialData.specularGlossinessMap = yield this.loadMap(pbrSpecularGlossiness.specularGlossinessTexture.index);
                }
            }
            else if (material.extensions && material.extensions.KHR_materials_unlit) {
                materialData.KHR_materials_unlit = true;
                materialData.color = '#ffffff';
                materialData.opacity = 1.0;
                if (material.pbrMetallicRoughness !== undefined) {
                    if (material.pbrMetallicRoughness.baseColorFactor !== undefined) {
                        materialData.color = this._converter.toColor([material.pbrMetallicRoughness.baseColorFactor[0] * 255, material.pbrMetallicRoughness.baseColorFactor[1] * 255, material.pbrMetallicRoughness.baseColorFactor[2] * 255]);
                        materialData.opacity = material.pbrMetallicRoughness.baseColorFactor[3];
                    }
                    if (material.pbrMetallicRoughness.baseColorTexture !== undefined) {
                        materialData.map = yield this.loadMap(material.pbrMetallicRoughness.baseColorTexture.index);
                    }
                }
            }
            else {
                if (material.pbrMetallicRoughness !== undefined) {
                    materialData.color = '#ffffff';
                    if (material.pbrMetallicRoughness.baseColorFactor !== undefined) {
                        materialData.color = this._converter.toColor([material.pbrMetallicRoughness.baseColorFactor[0] * 255, material.pbrMetallicRoughness.baseColorFactor[1] * 255, material.pbrMetallicRoughness.baseColorFactor[2] * 255]);
                        materialData.opacity = material.pbrMetallicRoughness.baseColorFactor[3];
                    }
                    if (material.pbrMetallicRoughness.baseColorTexture !== undefined) {
                        materialData.map = yield this.loadMap(material.pbrMetallicRoughness.baseColorTexture.index);
                    }
                    if (material.pbrMetallicRoughness.metallicFactor !== undefined) {
                        materialData.metalness = material.pbrMetallicRoughness.metallicFactor;
                    }
                    if (material.pbrMetallicRoughness.roughnessFactor !== undefined) {
                        materialData.roughness = material.pbrMetallicRoughness.roughnessFactor;
                    }
                    if (material.pbrMetallicRoughness.metallicRoughnessTexture !== undefined) {
                        materialData.metalnessRoughnessMap = yield this.loadMap(material.pbrMetallicRoughness.metallicRoughnessTexture.index);
                    }
                }
            }
            if (material.normalTexture !== undefined) {
                materialData.normalMap = yield this.loadMap(material.normalTexture.index);
                materialData.normalScale = 1;
                if (material.normalTexture.scale !== undefined) {
                    materialData.normalScale = material.normalTexture.scale;
                }
            }
            if (material.occlusionTexture !== undefined) {
                materialData.aoMap = yield this.loadMap(material.occlusionTexture.index);
                if (material.occlusionTexture.strength !== undefined) {
                    materialData.aoMapIntensity = material.occlusionTexture.strength;
                }
            }
            if (material.emissiveTexture !== undefined) {
                materialData.emissiveMap = yield this.loadMap(material.emissiveTexture.index);
            }
            if (material.emissiveFactor !== undefined) {
                materialData.emissiveness = this._converter.toColor([material.emissiveFactor[0] * 255, material.emissiveFactor[1] * 255, material.emissiveFactor[2] * 255]);
            }
            if (material.alphaMode !== undefined) {
                materialData.alphaMode = material.alphaMode.toLowerCase() === viewer_shared_types_1.MATERIAL_ALPHA.MASK ? viewer_shared_types_1.MATERIAL_ALPHA.MASK : material.alphaMode.toLowerCase() === viewer_shared_types_1.MATERIAL_ALPHA.BLEND ? viewer_shared_types_1.MATERIAL_ALPHA.BLEND : viewer_shared_types_1.MATERIAL_ALPHA.OPAQUE;
                if (materialData.alphaMode === viewer_shared_types_1.MATERIAL_ALPHA.MASK) {
                    materialData.alphaCutoff = material.alphaCutoff !== undefined ? material.alphaCutoff : 0.5;
                }
            }
            if (material.alphaCutoff !== undefined) {
                materialData.alphaCutoff = material.alphaCutoff;
            }
            if (material.doubleSided !== undefined) {
                materialData.side = material.doubleSided ? viewer_shared_types_1.MATERIAL_SIDE.DOUBLE : viewer_shared_types_1.MATERIAL_SIDE.FRONT;
            }
            return materialData;
        });
    }
    loadMesh(meshId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.meshes)
                throw new viewer_shared_services_1.SDError('Meshes not available.');
            if (!this._content.meshes[meshId])
                throw new viewer_shared_services_1.SDError('Mesh not available.');
            const mesh = this._content.meshes[meshId];
            const meshNode = new viewer_shared_node_tree_1.TreeNode(mesh.name || 'mesh_' + meshId);
            if (mesh.primitives)
                for (let i = 0, len = mesh.primitives.length; i < len; i++)
                    meshNode.addChild(yield this.loadPrimitive(mesh.primitives, i));
            return meshNode;
        });
    }
    loadNode(nodeId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.nodes)
                throw new viewer_shared_services_1.SDError('Nodes not available.');
            if (!this._content.nodes[nodeId])
                throw new viewer_shared_services_1.SDError('Node not available.');
            const node = this._content.nodes[nodeId];
            const nodeDef = new viewer_shared_node_tree_1.TreeNode(node.name || 'node_' + nodeId);
            this._nodes[nodeId] = nodeDef;
            if (node.matrix) {
                nodeDef.transformations.push({
                    id: 'gltf_matrix',
                    matrix: gl_matrix_1.mat4.fromValues(node.matrix[0], node.matrix[1], node.matrix[2], node.matrix[3], node.matrix[4], node.matrix[5], node.matrix[6], node.matrix[7], node.matrix[8], node.matrix[9], node.matrix[10], node.matrix[11], node.matrix[12], node.matrix[13], node.matrix[14], node.matrix[15])
                });
            }
            else if (node.translation || node.scale || node.rotation) {
                const matT = node.translation ? gl_matrix_1.mat4.fromTranslation(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(node.translation[0], node.translation[1], node.translation[2])) : gl_matrix_1.mat4.create();
                const matS = node.scale ? gl_matrix_1.mat4.fromScaling(gl_matrix_1.mat4.create(), gl_matrix_1.vec3.fromValues(node.scale[0], node.scale[1], node.scale[2])) : gl_matrix_1.mat4.create();
                const matR = node.rotation ? gl_matrix_1.mat4.fromQuat(gl_matrix_1.mat4.create(), gl_matrix_1.vec4.fromValues(node.rotation[0], node.rotation[1], node.rotation[2], node.rotation[3])) : gl_matrix_1.mat4.create();
                const matrix = gl_matrix_1.mat4.mul(gl_matrix_1.mat4.create(), gl_matrix_1.mat4.mul(gl_matrix_1.mat4.create(), matT, matS), matR);
                nodeDef.transformations.push({
                    id: 'gltf_matrix',
                    matrix: matrix
                });
            }
            if (node.mesh !== undefined)
                nodeDef.addChild(yield this.loadMesh(node.mesh));
            if (node.children) {
                for (let i = 0, len = node.children.length; i < len; i++) {
                    nodeDef.addChild(yield this.loadNode(node.children[i]));
                }
            }
            return nodeDef;
        });
    }
    loadPrimitive(primitives, index) {
        return __awaiter(this, void 0, void 0, function* () {
            const primitive = primitives[index];
            const primitiveNode = new viewer_shared_node_tree_1.TreeNode('primitive_' + index);
            const attributes = {};
            for (let attribute in primitive.attributes)
                attributes[attribute] = (yield this.loadAccessor(primitive.attributes[attribute]));
            let indices = null;
            if (primitive.indices || primitive.indices === 0)
                indices = yield this.loadAccessor(primitive.indices);
            let material = null;
            if (primitive.material || primitive.material === 0)
                material = yield this.loadMaterial(primitive.material);
            primitiveNode.data.push(new viewer_shared_types_1.GeometryData(new viewer_shared_types_1.PrimitiveData(attributes, primitive.mode, indices, material)));
            return primitiveNode;
        });
    }
    validateVersionAndExtensions() {
        if (!this._content.asset)
            throw new viewer_shared_services_1.SDError('Asset not available.');
        const asset = this._content.asset;
        if (!asset.version)
            throw new viewer_shared_services_1.SDError('Asset does not have a version.');
        const version = asset.minVersion ? asset.minVersion : asset.version;
        if (!version.startsWith('2'))
            throw new viewer_shared_services_1.SDError('Version of the glTF not supported.');
        if (this._content.extensionsUsed) {
            const notSupported = [];
            for (let i = 0; i < this._content.extensionsUsed.length; i++) {
                if (!Object.values(GLTF_EXTENSIONS).includes(this._content.extensionsUsed[i]))
                    notSupported.push(this._content.extensionsUsed[i]);
            }
            if (notSupported.length > 0) {
                let message = 'Extension' + (notSupported.length === 1 ? ' ' : 's ');
                notSupported.forEach((element, index) => {
                    message += '"' + element + '"' + (index === notSupported.length - 1 ? '' : index === notSupported.length - 2 ? ' and ' : ', ');
                });
                message += (notSupported.length === 1 ? ' is' : ' are') + ' not supported, but used. Loading glTF regardless.';
                this._logger.info(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, 'GLTFLoader.validateVersionAndExtensions: ' + message);
            }
        }
        if (this._content.extensionsRequired) {
            const notSupported = [];
            for (let i = 0; i < this._content.extensionsRequired.length; i++) {
                if (!Object.values(GLTF_EXTENSIONS).includes(this._content.extensionsRequired[i]))
                    notSupported.push(this._content.extensionsRequired[i]);
            }
            if (notSupported.length > 0) {
                let message = 'Extension' + (notSupported.length === 1 ? ' ' : 's ');
                notSupported.forEach((element, index) => {
                    message += '"' + element + '"' + (index === notSupported.length - 1 ? '' : index === notSupported.length - 2 ? ' and ' : ', ');
                });
                message += (notSupported.length === 1 ? ' is' : ' are') + ' not supported, but required. Aborting glTF loading.';
                throw new viewer_shared_services_1.SDError(message);
            }
        }
    }
    loadScene() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.scenes)
                throw new viewer_shared_services_1.SDError('Scenes not available.');
            const sceneID = this._content.scene || 0;
            if (!this._content.scenes[sceneID])
                throw new viewer_shared_services_1.SDError('Scene not available.');
            const scene = this._content.scenes[sceneID];
            const sceneDef = new viewer_shared_node_tree_1.TreeNode('scene_' + scene.name || sceneID + '');
            sceneDef.transformations.push({
                id: this._uuidGenerator.create(),
                matrix: this._globalTransformation
            });
            if (scene.nodes)
                for (let i = 0, len = scene.nodes.length; i < len; i++)
                    sceneDef.addChild(yield this.loadNode(scene.nodes[i]));
            return sceneDef;
        });
    }
    loadAnimation(animationId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._content.animations)
                throw new viewer_shared_services_1.SDError('Animations not available.');
            if (!this._content.animations[animationId])
                throw new viewer_shared_services_1.SDError('Animations not available.');
            const animationDef = this._content.animations[animationId];
            const animationTracks = [];
            let min = Infinity, max = -Infinity;
            for (let i = 0; i < animationDef.channels.length; i++) {
                const channel = animationDef.channels[i];
                const sampler = animationDef.samplers[channel.sampler];
                const target = channel.target;
                const path = target.path;
                const node = this._nodes[target.node];
                if (node === undefined)
                    throw new viewer_shared_services_1.SDError('Animation node not available.');
                const input = yield this.loadAccessor(sampler.input);
                min = Math.min(min, input.min[0]);
                max = Math.max(max, input.max[0]);
                const output = yield this.loadAccessor(sampler.output);
                let interpolation = sampler.interpolation;
                if (interpolation === 'CUBICSPLINE') {
                    this._logger.warn(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, 'Animation with CUBICSPLINE interpolation is currently not supported. Assigning linear interpolation instead.');
                    interpolation = 'linear';
                }
                if (target.path === 'weights') {
                    this._logger.warn(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, 'Animation with weights is currently not supported.');
                    break;
                }
                animationTracks.push({
                    node,
                    times: input.array,
                    values: output.array,
                    path: path,
                    interpolation: interpolation
                });
            }
            return new viewer_shared_types_1.AnimationData(animationDef.name || 'gltf_animation_' + animationId, animationTracks, min, max - min);
        });
    }
}
exports.GLTFLoader = GLTFLoader;
//# sourceMappingURL=GLTFLoader.js.map