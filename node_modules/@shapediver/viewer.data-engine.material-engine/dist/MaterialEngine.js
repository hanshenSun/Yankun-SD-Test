"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MaterialEngine = void 0;
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const tsyringe_1 = require("tsyringe");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const gl_matrix_1 = require("gl-matrix");
const materialDatabase_1 = require("./materialDatabase");
let MaterialEngine = class MaterialEngine {
    constructor() {
        this._imageLoader = tsyringe_1.container.resolve(viewer_shared_services_1.ImageLoader);
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
        this._converter = tsyringe_1.container.resolve(viewer_shared_services_1.Converter);
    }
    loadContent(content) {
        return __awaiter(this, void 0, void 0, function* () {
            const node = new viewer_shared_node_tree_1.TreeNode(content.name || 'material');
            if (!content) {
                this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, new viewer_shared_services_1.SDError('MaterialEngine.loadContent: Invalid content was provided to material engine.'));
                return node;
            }
            const material = new viewer_shared_types_1.MaterialData();
            node.data.push(material);
            if (content.data) {
                if (content.data.materialpreset)
                    yield this.loadPresetMaterial(content.data.materialpreset, material);
                if (content.data.materialType && content.data.materialType !== 'standard') {
                }
                else {
                    if (content.data.version) {
                        if (content.data.version === '1.0')
                            yield this.loadMaterialV1(content.data, material);
                        if (content.data.version === '2.0')
                            yield this.loadMaterialV2(content.data, material);
                        if (content.data.version === '3.0')
                            yield this.loadMaterialV3(content.data, material);
                    }
                }
            }
            else {
                this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, new viewer_shared_services_1.SDError('MaterialEngine.loadContent: No material data was provided to material engine.'));
            }
            return node;
        });
    }
    assignGeneralDefinition(id, generalDefinition, specificDefinition, material) {
        return __awaiter(this, void 0, void 0, function* () {
            if (generalDefinition.transparencytexture && !specificDefinition.transparencytexture) {
                const map = yield this.loadMap(generalDefinition.transparencytexture, id.class);
                if (map)
                    material.alphaMap = map;
            }
            if (generalDefinition.hasOwnProperty('alphaThreshold') && !specificDefinition.hasOwnProperty('alphaThreshold'))
                material.alphaCutoff = generalDefinition.alphaThreshold;
            if (generalDefinition.bumptexture && !specificDefinition.bumptexture) {
                const map = yield this.loadMap(generalDefinition.bumptexture, id.class);
                if (map)
                    material.bumpMap = map;
            }
            if (generalDefinition.hasOwnProperty('bumpAmplitude') && !specificDefinition.hasOwnProperty('bumpAmplitude'))
                material.bumpScale = generalDefinition.bumpAmplitude;
            if (generalDefinition.color && !specificDefinition.color)
                material.color = this._converter.toColor(generalDefinition.color);
            if (generalDefinition.bitmaptexture && !specificDefinition.bitmaptexture) {
                const map = yield this.loadMap(generalDefinition.bitmaptexture, id.class);
                if (map)
                    material.map = map;
            }
            if (generalDefinition.hasOwnProperty('metalness') && !specificDefinition.hasOwnProperty('metalness'))
                material.metalness = generalDefinition.metalness;
            if (generalDefinition.metalnesstexture && !specificDefinition.metalnesstexture) {
                const map = yield this.loadMap(generalDefinition.metalnesstexture, id.class);
                if (map)
                    material.metalnessMap = map;
            }
            if (generalDefinition.normaltexture && !specificDefinition.normaltexture) {
                const map = yield this.loadMap(generalDefinition.normaltexture, id.class);
                if (map)
                    material.normalMap = map;
            }
            if (generalDefinition.hasOwnProperty('transparency') && !specificDefinition.hasOwnProperty('transparency'))
                material.opacity = 1 - generalDefinition.transparency;
            if (generalDefinition.hasOwnProperty('roughness') && !specificDefinition.hasOwnProperty('roughness'))
                material.roughness = generalDefinition.roughness;
            if (generalDefinition.roughnesstexture && !specificDefinition.roughnesstexture) {
                const map = yield this.loadMap(generalDefinition.roughnesstexture, id.class);
                if (map)
                    material.roughnessMap = map;
            }
            if (generalDefinition.side && !specificDefinition.side)
                material.side = generalDefinition.side === 'front' ? viewer_shared_types_1.MATERIAL_SIDE.FRONT : generalDefinition.side === 'back' ? viewer_shared_types_1.MATERIAL_SIDE.BACK : viewer_shared_types_1.MATERIAL_SIDE.DOUBLE;
        });
    }
    assignSpecificDefinition(id, specificDefinition, material) {
        return __awaiter(this, void 0, void 0, function* () {
            if (specificDefinition.transparencytexture) {
                const map = yield this.loadMap(specificDefinition.transparencytexture, id.class + '/' + id.specific);
                if (map)
                    material.alphaMap = map;
            }
            if (specificDefinition.hasOwnProperty('alphaThreshold'))
                material.alphaCutoff = specificDefinition.alphaThreshold;
            if (specificDefinition.bumptexture) {
                const map = yield this.loadMap(specificDefinition.bumptexture, id.class + '/' + id.specific);
                if (map)
                    material.bumpMap = map;
            }
            if (specificDefinition.hasOwnProperty('bumpAmplitude'))
                material.bumpScale = specificDefinition.bumpAmplitude;
            if (specificDefinition.color)
                material.color = this._converter.toColor(specificDefinition.color);
            if (specificDefinition.bitmaptexture) {
                const map = yield this.loadMap(specificDefinition.bitmaptexture, id.class + '/' + id.specific);
                if (map)
                    material.map = map;
            }
            if (specificDefinition.hasOwnProperty('metalness'))
                material.metalness = specificDefinition.metalness;
            if (specificDefinition.metalnesstexture) {
                const map = yield this.loadMap(specificDefinition.metalnesstexture, id.class + '/' + id.specific);
                if (map)
                    material.metalnessMap = map;
            }
            if (specificDefinition.normaltexture) {
                const map = yield this.loadMap(specificDefinition.normaltexture, id.class + '/' + id.specific);
                if (map)
                    material.normalMap = map;
            }
            if (specificDefinition.hasOwnProperty('transparency'))
                material.opacity = 1 - specificDefinition.transparency;
            if (specificDefinition.hasOwnProperty('roughness'))
                material.roughness = specificDefinition.roughness;
            if (specificDefinition.roughnesstexture) {
                const map = yield this.loadMap(specificDefinition.roughnesstexture, id.class + '/' + id.specific);
                if (map)
                    material.roughnessMap = map;
            }
            if (specificDefinition.side)
                material.side = specificDefinition.side === 'front' ? viewer_shared_types_1.MATERIAL_SIDE.FRONT : specificDefinition.side === 'back' ? viewer_shared_types_1.MATERIAL_SIDE.BACK : viewer_shared_types_1.MATERIAL_SIDE.DOUBLE;
        });
    }
    getClassAndSpecificID(id) {
        if (id < 100 && id % 10 == 0)
            id /= 10;
        if (id < 10)
            id *= 100;
        const cast = (id) => {
            let idString = String(id);
            return idString.padStart(2, '0').slice(0, 2);
        };
        return {
            class: cast(Math.floor(id / 100)),
            specific: cast(id - (Math.floor(id / 100) * 100))
        };
    }
    loadMap(url, id) {
        return __awaiter(this, void 0, void 0, function* () {
            let image;
            try {
                if (!id) {
                    image = yield this._imageLoader.load(url);
                }
                else {
                    image = yield this._imageLoader.load('https://viewer.shapediver.com/v2/materials/1024/' + id + '/' + url);
                }
            }
            catch (e) {
                if (e.response && e.response.status) {
                    this._logger.httpError(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, e, `MaterialEngine.loadMap: Loading of map failed.`, e.response.status, false);
                }
                else {
                    this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, e, `MaterialEngine.loadMap: Loading of map failed.`, false);
                }
                return null;
            }
            return new viewer_shared_types_1.MapData(image);
        });
    }
    loadMapWithProperties(texture) {
        return __awaiter(this, void 0, void 0, function* () {
            let image;
            try {
                image = yield this._imageLoader.load(texture.href);
            }
            catch (e) {
                if (e.response && e.response.status) {
                    this._logger.httpError(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, e, `MaterialEngine.loadMapWithProperties: Loading of map failed.`, e.response.status, false);
                }
                else {
                    this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, e, `MaterialEngine.loadMapWithProperties: Loading of map failed.`, false);
                }
                return null;
            }
            const wrapS = texture.wrapS === 1 ? viewer_shared_types_1.TEXTURE_WRAPPING.CLAMP_TO_EDGE : texture.wrapS === 2 ? viewer_shared_types_1.TEXTURE_WRAPPING.MIRRORED_REPEAT : viewer_shared_types_1.TEXTURE_WRAPPING.REPEAT;
            const wrapT = texture.wrapT === 1 ? viewer_shared_types_1.TEXTURE_WRAPPING.CLAMP_TO_EDGE : texture.wrapT === 2 ? viewer_shared_types_1.TEXTURE_WRAPPING.MIRRORED_REPEAT : viewer_shared_types_1.TEXTURE_WRAPPING.REPEAT;
            const center = texture.center ? gl_matrix_1.vec2.fromValues(texture.center[0], texture.center[1]) : gl_matrix_1.vec2.fromValues(0, 0);
            const color = texture.color ? gl_matrix_1.vec4.fromValues(texture.color[0] / 255, texture.color[1] / 255, texture.color[2] / 255, texture.color[3] / 255) : gl_matrix_1.vec4.fromValues(1, 1, 1, 1);
            const offset = texture.offset ? gl_matrix_1.vec2.fromValues(texture.offset[0], texture.offset[1]) : gl_matrix_1.vec2.fromValues(0, 0);
            const repeat = texture.repeat ? gl_matrix_1.vec2.fromValues(texture.repeat[0], texture.repeat[1]) : gl_matrix_1.vec2.fromValues(1, 1);
            return new viewer_shared_types_1.MapData(image, wrapS, wrapT, viewer_shared_types_1.TEXTURE_FILTERING.LINEAR_MIPMAP_LINEAR, viewer_shared_types_1.TEXTURE_FILTERING.LINEAR, center, this._converter.toColor(color), offset, repeat, texture.rotation || 0);
        });
    }
    loadMaterialV1(data, material) {
        return __awaiter(this, void 0, void 0, function* () {
            if (data.color) {
                material.color = this._converter.toColor(data.color);
            }
            else if (data.diffuse) {
                material.color = this._converter.toColor(data.diffuse);
            }
            if (data.emission)
                material.emissiveness = this._converter.toColor(data.emission);
            if (data.shine || data.shine === 0) {
                material.metalness = Math.min(1, data.shine);
                material.roughness = 1 - (Math.min(1, data.shine));
            }
            if (data.hasOwnProperty('transparency'))
                material.opacity = 1 - data.transparency;
            if (data.bitmaptexture) {
                const map = yield this.loadMap(data.bitmaptexture);
                if (map)
                    material.map = map;
            }
            if (data.bumptexture) {
                const map = yield this.loadMap(data.bumptexture);
                if (map)
                    material.bumpMap = map;
            }
            if (data.transparencytexture) {
                const map = yield this.loadMap(data.transparencytexture);
                if (map)
                    material.alphaMap = map;
            }
        });
    }
    loadMaterialV2(data, material) {
        return __awaiter(this, void 0, void 0, function* () {
            if (data.color)
                material.color = this._converter.toColor(data.color);
            material.side = data.side === 'front' ? viewer_shared_types_1.MATERIAL_SIDE.FRONT : data.side === 'back' ? viewer_shared_types_1.MATERIAL_SIDE.BACK : viewer_shared_types_1.MATERIAL_SIDE.DOUBLE;
            if (data.metalness || data.metalness === 0)
                material.metalness = data.metalness;
            if (data.roughness || data.roughness === 0)
                material.roughness = data.roughness;
            if (data.hasOwnProperty('transparency'))
                material.opacity = 1 - data.transparency;
            if (data.alphaThreshold || data.alphaThreshold === 0)
                material.alphaCutoff = data.alphaThreshold;
            if (data.bitmaptexture) {
                const map = yield this.loadMap(data.bitmaptexture);
                if (map)
                    material.map = map;
            }
            if (data.metalnesstexture) {
                const map = yield this.loadMap(data.metalnesstexture);
                if (map)
                    material.metalnessMap = map;
            }
            if (data.roughnesstexture) {
                const map = yield this.loadMap(data.roughnesstexture);
                if (map)
                    material.roughnessMap = map;
            }
            if (data.bumptexture) {
                const map = yield this.loadMap(data.bumptexture);
                if (map)
                    material.bumpMap = map;
            }
            if (data.normaltexture) {
                const map = yield this.loadMap(data.normaltexture);
                if (map)
                    material.normalMap = map;
            }
            if (data.transparencytexture) {
                const map = yield this.loadMap(data.transparencytexture);
                if (map)
                    material.alphaMap = map;
            }
        });
    }
    loadMaterialV3(data, material) {
        return __awaiter(this, void 0, void 0, function* () {
            if (data.color)
                material.color = this._converter.toColor(data.color);
            material.side = data.side === 'front' ? viewer_shared_types_1.MATERIAL_SIDE.FRONT : data.side === 'back' ? viewer_shared_types_1.MATERIAL_SIDE.BACK : viewer_shared_types_1.MATERIAL_SIDE.DOUBLE;
            if (data.metalness || data.metalness === 0)
                material.metalness = data.metalness;
            if (data.roughness || data.roughness === 0)
                material.roughness = data.roughness;
            if (data.hasOwnProperty('transparency'))
                material.opacity = 1 - data.transparency;
            if (data.alphaThreshold || data.alphaThreshold === 0)
                material.alphaCutoff = data.alphaThreshold;
            if (data.bumpAmplitude || data.bumpAmplitude === 0)
                material.bumpScale = data.bumpAmplitude;
            if (data.bitmaptexture) {
                const map = yield this.loadMapWithProperties(data.bitmaptexture);
                if (map)
                    material.map = map;
            }
            if (data.metalnesstexture) {
                const map = yield this.loadMapWithProperties(data.metalnesstexture);
                if (map)
                    material.metalnessMap = map;
            }
            if (data.roughnesstexture) {
                const map = yield this.loadMapWithProperties(data.roughnesstexture);
                if (map)
                    material.roughnessMap = map;
            }
            if (data.bumptexture) {
                const map = yield this.loadMapWithProperties(data.bumptexture);
                if (map)
                    material.bumpMap = map;
            }
            if (data.normaltexture) {
                const map = yield this.loadMapWithProperties(data.normaltexture);
                if (map)
                    material.normalMap = map;
            }
            if (data.transparencytexture) {
                const map = yield this.loadMapWithProperties(data.transparencytexture);
                if (map)
                    material.alphaMap = map;
            }
        });
    }
    loadPresetMaterial(preset, material) {
        return __awaiter(this, void 0, void 0, function* () {
            const idStrings = this.getClassAndSpecificID(preset);
            if (materialDatabase_1.materialDatabase[idStrings.class] && materialDatabase_1.materialDatabase[idStrings.class][idStrings.specific]) {
                yield this.assignSpecificDefinition(idStrings, materialDatabase_1.materialDatabase[idStrings.class][idStrings.specific], material);
                yield this.assignGeneralDefinition(idStrings, materialDatabase_1.materialDatabase[idStrings.class].properties, materialDatabase_1.materialDatabase[idStrings.class][idStrings.specific], material);
            }
            else if (materialDatabase_1.materialDatabase[idStrings.class]['00']) {
                yield this.assignSpecificDefinition({ class: idStrings.class, specific: '00' }, materialDatabase_1.materialDatabase[idStrings.class]['00'], material);
                yield this.assignGeneralDefinition({ class: idStrings.class, specific: '00' }, materialDatabase_1.materialDatabase[idStrings.class].properties, materialDatabase_1.materialDatabase[idStrings.class]['00'], material);
            }
            else {
                yield this.assignSpecificDefinition({ class: '00', specific: '00' }, materialDatabase_1.materialDatabase['00']['00'], material);
                yield this.assignGeneralDefinition({ class: '00', specific: '00' }, materialDatabase_1.materialDatabase['00'].properties, materialDatabase_1.materialDatabase['00']['00'], material);
            }
        });
    }
};
MaterialEngine = __decorate([
    tsyringe_1.singleton(),
    __metadata("design:paramtypes", [])
], MaterialEngine);
exports.MaterialEngine = MaterialEngine;
//# sourceMappingURL=MaterialEngine.js.map