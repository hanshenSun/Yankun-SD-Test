"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MaterialLoader = void 0;
const THREE = __importStar(require("three"));
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const PCSS_1 = require("../shaders/PCSS");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const tsyringe_1 = require("tsyringe");
class MaterialLoader {
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        this._defaultColor = '#00fff7';
        this._converter = tsyringe_1.container.resolve(viewer_shared_services_1.Converter);
        this._materialCache = {};
        this._blending = 0.0;
        this._envMap = null;
        this._envMapIntensity = 1;
        this._height = 1020;
        this._lightSizeUV = 0.025;
        this._pointSize = 1.0;
        this._textureEncoding = THREE.LinearEncoding;
        this._maxMapCount = 0;
        let shader = THREE.ShaderChunk.shadowmap_pars_fragment;
        if (!shader.includes('PCSS implementation')) {
            shader = shader.replace('#ifdef USE_SHADOWMAP', '#ifdef USE_SHADOWMAP' + PCSS_1.main);
            shader = shader.replace(shader.substr(shader.indexOf('#if defined( SHADOWMAP_TYPE_PCF )'), shader.indexOf('#elif defined( SHADOWMAP_TYPE_PCF_SOFT )') - shader.indexOf('#if defined( SHADOWMAP_TYPE_PCF )')), '#if defined( SHADOWMAP_TYPE_PCF )\n' + PCSS_1.entry);
        }
        THREE.ShaderChunk.shadowmap_pars_fragment = shader;
        THREE.ShaderChunk.envmap_fragment = THREE.ShaderChunk.envmap_fragment.replace(`vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );`, `vec4 envColor = textureCubeUV( envMap, reflectVec.xzy, 0.0 );`);
        THREE.ShaderChunk.envmap_physical_pars_fragment = THREE.ShaderChunk.envmap_physical_pars_fragment.replace(`vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );`, `vec4 envMapColor = textureCubeUV( envMap, worldNormal.xzy, 1.0 );`);
        THREE.ShaderChunk.envmap_physical_pars_fragment = THREE.ShaderChunk.envmap_physical_pars_fragment.replace(`vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );`, `vec4 envMapColor = textureCubeUV( envMap, reflectVec.xzy, roughness );`);
    }
    assignEnvironmentMap(e) {
        this._envMap = e;
        for (let m in this._materialCache) {
            if ((this._materialCache[m] instanceof THREE.MeshStandardMaterial || this._materialCache[m] instanceof THREE.MeshBasicMaterial)
                && !this._materialCache[m].KHR_materials_unlit) {
                this._materialCache[m].envMap = e;
                this._materialCache[m].needsUpdate = true;
            }
        }
    }
    assignEnvironmentMapIntensity(e) {
        this._envMapIntensity = e;
        for (let m in this._materialCache) {
            if ((this._materialCache[m] instanceof THREE.MeshStandardMaterial)
                && !this._materialCache[m].KHR_materials_unlit) {
                this._materialCache[m].envMapIntensity = e;
                this._materialCache[m].needsUpdate = true;
            }
        }
    }
    assignPointSize(p) {
        const height = this._renderingEngine.renderer ? this._renderingEngine.renderer.getSize(new THREE.Vector2()).y : 1080;
        if (height === this._height && p * (this._height / 1080) === this._pointSize)
            return;
        this._height = height;
        this._pointSize = p * (this._height / 1080);
        for (let m in this._materialCache) {
            if (this._materialCache[m] instanceof THREE.PointsMaterial) {
                this._materialCache[m].size = this._pointSize;
                this._materialCache[m].needsUpdate = true;
            }
        }
    }
    assignTextureEncoding(e) {
        this._textureEncoding = e;
        for (let m in this._materialCache) {
            if (this._materialCache[m] instanceof THREE.MeshStandardMaterial) {
                if (this._materialCache[m].emissiveMap)
                    this._materialCache[m].emissiveMap.encoding = e;
                if (this._materialCache[m].map)
                    this._materialCache[m].map.encoding = e;
                this._materialCache[m].needsUpdate = true;
            }
        }
    }
    emptyMaterialCache() {
        this._materialCache = {};
    }
    removeFromMaterialCache(id) {
        if (this._materialCache[id])
            delete this._materialCache[id];
    }
    init() { }
    load(visualizationData, materialProperties, materialSettings) {
        let mapCount = 0;
        const properties = {};
        properties.color = new THREE.Color(visualizationData.color);
        properties.side = THREE.DoubleSide;
        if (visualizationData.opacity < 1) {
            properties.opacity = visualizationData.opacity;
            properties.transparent = true;
        }
        let material = new THREE.MeshBasicMaterial(properties);
        if (materialProperties) {
            material.userData = {
                SDid: materialProperties.id,
                SDversion: materialProperties.version
            };
            this._materialCache[materialProperties.id + '_' + materialProperties.version] = material;
        }
        this.maxMapCount = Math.max(this.maxMapCount, mapCount);
        return material;
    }
    updateMaterials() {
        for (let m in this._materialCache)
            this._materialCache[m].needsUpdate = true;
    }
    updateSoftShadow(lightSizeUV, blending) {
        this._lightSizeUV = lightSizeUV;
        this._blending = blending;
        for (let m in this._materialCache) {
            if (this._materialCache[m].userData.shader) {
                this._materialCache[m].userData.shader.uniforms.lightSizeUV.value = lightSizeUV;
                this._materialCache[m].userData.shader.uniforms.blending.value = blending;
            }
        }
    }
    createTexture(map) {
        const texture = new THREE.Texture(map.image);
        texture.format = THREE.RGBAFormat;
        texture.minFilter = (() => {
            switch (map.minFilter) {
                case viewer_shared_types_1.TEXTURE_FILTERING.NEAREST:
                    return THREE.NearestFilter;
                case viewer_shared_types_1.TEXTURE_FILTERING.NEAREST_MIPMAP_NEAREST:
                    return THREE.NearestMipMapNearestFilter;
                case viewer_shared_types_1.TEXTURE_FILTERING.LINEAR_MIPMAP_NEAREST:
                    return THREE.LinearMipMapNearestFilter;
                case viewer_shared_types_1.TEXTURE_FILTERING.NEAREST_MIPMAP_LINEAR:
                    return THREE.NearestMipMapLinearFilter;
                case viewer_shared_types_1.TEXTURE_FILTERING.LINEAR:
                    return THREE.LinearFilter;
                case viewer_shared_types_1.TEXTURE_FILTERING.LINEAR_MIPMAP_LINEAR:
                default:
                    return THREE.LinearMipMapLinearFilter;
            }
        })();
        texture.magFilter = (() => {
            switch (map.magFilter) {
                case viewer_shared_types_1.TEXTURE_FILTERING.NEAREST:
                    return THREE.NearestFilter;
                case viewer_shared_types_1.TEXTURE_FILTERING.LINEAR:
                default:
                    return THREE.LinearFilter;
            }
        })();
        texture.wrapS = (() => {
            switch (map.wrapS) {
                case viewer_shared_types_1.TEXTURE_WRAPPING.CLAMP_TO_EDGE:
                    return THREE.ClampToEdgeWrapping;
                case viewer_shared_types_1.TEXTURE_WRAPPING.MIRRORED_REPEAT:
                    return THREE.MirroredRepeatWrapping;
                case viewer_shared_types_1.TEXTURE_WRAPPING.REPEAT:
                default:
                    return THREE.RepeatWrapping;
            }
        })();
        texture.wrapT = (() => {
            switch (map.wrapT) {
                case viewer_shared_types_1.TEXTURE_WRAPPING.CLAMP_TO_EDGE:
                    return THREE.ClampToEdgeWrapping;
                case viewer_shared_types_1.TEXTURE_WRAPPING.MIRRORED_REPEAT:
                    return THREE.MirroredRepeatWrapping;
                case viewer_shared_types_1.TEXTURE_WRAPPING.REPEAT:
                default:
                    return THREE.RepeatWrapping;
            }
        })();
        texture.center = new THREE.Vector2(map.center[0], map.center[1]);
        texture.offset = new THREE.Vector2(map.offset[0], map.offset[1]);
        texture.repeat = new THREE.Vector2(map.repeat[0], map.repeat[1]);
        texture.rotation = map.rotation;
        texture.flipY = map.flipY;
        texture.needsUpdate = true;
        return texture;
    }
    get maxMapCount() {
        return this._maxMapCount;
    }
    set maxMapCount(value) {
        this._maxMapCount = value;
    }
}
exports.MaterialLoader = MaterialLoader;
//# sourceMappingURL=MaterialLoader.js.map