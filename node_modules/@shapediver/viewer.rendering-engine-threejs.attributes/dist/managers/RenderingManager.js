"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RenderingManager = void 0;
const TWEEN = __importStar(require("@tweenjs/tween.js"));
const Stats = __importStar(require("stats.js"));
const THREE = __importStar(require("three"));
const viewer_rendering_engine_camera_engine_1 = require("@shapediver/viewer.rendering-engine.camera-engine");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const gl_matrix_1 = require("gl-matrix");
const tsyringe_1 = require("tsyringe");
class RenderingManager {
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        this._eventEngine = tsyringe_1.container.resolve(viewer_shared_services_1.EventEngine);
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
        this._stateEngine = tsyringe_1.container.resolve(viewer_shared_services_1.StateEngine);
        this._systemInfo = tsyringe_1.container.resolve(viewer_shared_services_1.SystemInfo);
        this._activeRendering = true;
        this._cameraChanged = false;
        this._height = 0;
        this._lastCamera = {
            position: gl_matrix_1.vec3.create(),
            target: gl_matrix_1.vec3.create()
        };
        this._lastSize = {
            adjustedWidth: 0,
            adjustedHeight: 0,
            width: 0,
            height: 0
        };
        this._lastTime = 0;
        this._minimalRendering = false;
        this._noWebGL = false;
        this._sizeChanged = false;
        this._usingSwiftShader = false;
        this._width = 0;
        this._maxTextureUnits = 0;
    }
    get minimalRendering() {
        return this._minimalRendering;
    }
    get usingSwiftShader() {
        return this._usingSwiftShader;
    }
    addLogo(canvas, logo) {
        var _a, _b;
        const logoDivElement = document.createElement('div');
        logoDivElement.style.background = '#030531';
        logoDivElement.style.position = 'relative';
        logoDivElement.style.height = '100%';
        logoDivElement.style.width = '100%';
        (_a = canvas.parentElement) === null || _a === void 0 ? void 0 : _a.insertBefore(logoDivElement, (_b = canvas.parentElement) === null || _b === void 0 ? void 0 : _b.firstChild);
        const img = new Image();
        img.style.position = 'absolute';
        img.style.top = '50%';
        img.style.left = '50%';
        img.style.transform = 'translateX(-50%) translateY(-50%)';
        img.src = logo;
        logoDivElement.appendChild(img);
        return logoDivElement;
    }
    createRenderer(canvas) {
        const renderingProperties = {
            alpha: true,
            depth: true,
            antialias: true,
            preserveDrawingBuffer: true,
            canvas
        };
        const context = this.createWebGLContext(renderingProperties);
        const renderer = new THREE.WebGLRenderer(Object.assign({ context }, renderingProperties));
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.physicallyCorrectLights = false;
        renderer.outputEncoding = THREE.LinearEncoding;
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.needsUpdate = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.shadowMap.autoUpdate = false;
        renderer.setSize(canvas.width, canvas.height);
        renderer.setClearColor(new THREE.Color('#ffffff'), 1);
        this._maxTextureUnits = renderer.context.getParameter(renderer.context.MAX_TEXTURE_IMAGE_UNITS);
        return renderer;
    }
    evaluateTextureUnitCount(value) {
        if (value > this._maxTextureUnits) {
            this._logger.warn(viewer_shared_services_1.LOGGINGTOPIC.VIEWER, `RenderingManager.evaluateTextureUnitCount: Maximum number of texture units exceeded. Disabling shadows.`);
            this._renderingEngine.lightLoader.forceDisabledShadows = true;
            this._renderingEngine.update();
        }
        else {
            this._renderingEngine.lightLoader.forceDisabledShadows = false;
        }
    }
    getScreenshot(type = 'image/png', encoderOptions = 1) {
        return this._renderingEngine.renderer.domElement.toDataURL(type, encoderOptions);
    }
    init() {
        try {
            this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.CAMERA.CAMERA_START, (e) => {
                const viewerEvent = e;
                if (viewerEvent.viewerId === this._renderingEngine.id)
                    this.startRendering();
            });
            this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.CAMERA.CAMERA_END, (e) => {
                const viewerEvent = e;
                if (viewerEvent.viewerId === this._renderingEngine.id)
                    this.stopRendering();
            });
            window.onresize = () => { this.render(); };
            this._renderingEngine.canvas.canvasElement.onresize = () => { this.render(); };
            this._renderingEngine.canvas.canvasElement.parentElement.onresize = () => { this.render(); };
            const stats1 = new Stats.default();
            stats1.showPanel(0);
            stats1.dom.style.cssText = 'position:absolute;top:0px;left:0px;display:none;';
            this._renderingEngine.canvas.canvasElement.parentElement.appendChild(stats1.dom);
            const stats2 = new Stats.default();
            stats2.showPanel(1);
            stats2.dom.style.cssText = 'position:absolute;top:0px;left:80px;display:none;';
            this._renderingEngine.canvas.canvasElement.parentElement.appendChild(stats2.dom);
            const stats3 = new Stats.default();
            stats3.showPanel(2);
            stats3.dom.style.cssText = 'position:absolute;top:0px;left:160px;display:none;';
            this._renderingEngine.canvas.canvasElement.parentElement.appendChild(stats3.dom);
            this._stats = {
                stats: [stats1, stats2, stats3],
                begin: () => {
                    stats1.begin();
                    stats2.begin();
                    stats3.begin();
                },
                end: () => {
                    stats1.end();
                    stats2.end();
                    stats3.end();
                }
            };
        }
        catch (e) {
            this._noWebGL = true;
            throw e;
        }
    }
    render() {
        this.startAndStopRendering();
    }
    resize(width, height) {
        this._width = width, this._height = height;
    }
    start() {
        this.animate(0);
        this.startAndStopRendering();
    }
    updateShadowMap() {
        this._renderingEngine.renderer.shadowMap.needsUpdate = true;
    }
    animate(time) {
        if (this._renderingEngine.closed || this._noWebGL)
            return;
        requestAnimationFrame((time) => this.animate(time));
        TWEEN.update(time);
        const deltaTime = time - this._lastTime < 0 ? 0 : time - this._lastTime;
        this._lastTime = time;
        const { width, height, adjustedWidth, adjustedHeight } = this.calculateSize();
        const aspect = width / height;
        this._sizeChanged = this._lastSize.adjustedHeight !== adjustedHeight || this._lastSize.adjustedWidth !== adjustedWidth || this._lastSize.height !== height || this._lastSize.width !== width;
        this._lastSize = { width, height, adjustedWidth, adjustedHeight };
        const { position, target } = this._renderingEngine.cameraEngine.camera ? this._renderingEngine.cameraManager.updateCamera(deltaTime, aspect) : { position: gl_matrix_1.vec3.create(), target: gl_matrix_1.vec3.create() };
        this._cameraChanged = true;
        if (position[0] === this._lastCamera.position[0] && position[1] === this._lastCamera.position[1] && position[2] === this._lastCamera.position[2] &&
            target[0] === this._lastCamera.target[0] && target[1] === this._lastCamera.target[1] && target[2] === this._lastCamera.target[2])
            this._cameraChanged = false;
        this._lastCamera = { position, target };
        const states = this.evaluateRenderingState();
        if (states.showScene === false) {
            this.toggleLogo(true);
            return;
        }
        else {
            this.toggleLogo(false);
        }
        if (states.rendering === false)
            return;
        this._stats.begin();
        this.showStatistics();
        this.toggleBlur(states.blurScene);
        this._renderingEngine.renderer.setSize(adjustedWidth, adjustedHeight);
        this._renderingEngine.renderer.domElement.style.width = width + 'px';
        this._renderingEngine.renderer.domElement.style.height = height + 'px';
        this._renderingEngine.materialLoader.assignPointSize(this._renderingEngine.pointSize);
        const camera = this._renderingEngine.cameraManager.adjustCamera(position, target, aspect);
        const enabled = this._renderingEngine.renderer.shadowMap.enabled;
        this._renderingEngine.renderer.shadowMap.enabled = false;
        if (enabled !== this._renderingEngine.renderer.shadowMap.enabled)
            this._renderingEngine.materialLoader.updateMaterials();
        this._renderingEngine.sceneTreeManager.scene.background = null;
        this._renderingEngine.renderer.setClearColor(new THREE.Color('black'), 1);
        this._renderingEngine.renderer.render(this._renderingEngine.sceneTreeManager.scene, camera);
        this._activeRendering = false;
        if (!this._stateEngine.firstViewerShown.resolved)
            this._stateEngine.firstViewerShown.resolve(true);
        this._stats.end();
    }
    calculateSize() {
        let width = this._width, height = this._height;
        if (this._renderingEngine.automaticResizing) {
            width = this._renderingEngine.canvas.canvasElement.parentNode.clientWidth;
            height = this._renderingEngine.canvas.canvasElement.parentNode.clientHeight;
        }
        const aspect = width / height;
        let adjustedWidth = width, adjustedHeight = height;
        if (width > 1920 || height > 1080) {
            if ((width - 1920) / aspect > (height - 1080)) {
                adjustedWidth = 1920;
                adjustedHeight = 1920 / aspect;
            }
            else {
                adjustedWidth = 1080 * aspect;
                adjustedHeight = 1080;
            }
        }
        return {
            width, adjustedWidth,
            height, adjustedHeight
        };
    }
    createWebGLContext(properties) {
        try {
            let canvas = properties.canvas;
            canvas.addEventListener('webglcontextlost', () => { }, false);
            canvas.addEventListener('webglcontextrestored', () => { }, false);
            const props = Object.assign({
                stencil: true,
                premultipliedAlpha: true,
                powerPreference: 'default'
            }, properties);
            let _gl = canvas.getContext('webgl', props) || canvas.getContext('experimental-webgl', props);
            if (_gl === null) {
                _gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (_gl !== null) {
                    this._logger.warn(viewer_shared_services_1.LOGGINGTOPIC.VIEWER, 'RenderingLogic.createWebGLContext: We were unable to get a WebGL context using the requested attributes, falling back to default attributes.');
                }
                else {
                    throw new viewer_shared_services_1.SDError('We were unable to get a WebGL context.');
                }
            }
            if (_gl.getShaderPrecisionFormat === undefined) {
                _gl.getShaderPrecisionFormat = function () {
                    return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };
                };
            }
            const debugInfo = _gl.getExtension("WEBGL_debug_renderer_info");
            if (debugInfo) {
                const vendor = _gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
                const renderer = _gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
                if (renderer === "Google SwiftShader") {
                    this._usingSwiftShader = true;
                    this._logger.warn(viewer_shared_services_1.LOGGINGTOPIC.VIEWER, 'RenderingLogic.createWebGLContext: The current device is using Google SwiftShader, a CPU-based renderer. To achieve better rendering results, please enable GPU-rendering in your settings.');
                }
            }
            if (!_gl.getExtension("EXT_shader_texture_lod"))
                this._minimalRendering = true;
            return _gl;
        }
        catch (error) {
            throw this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.VIEWER, new viewer_shared_services_1.SDError('RenderingLogic.createWebGLContext: We were unable to get a WebGL context.', error), '', true);
        }
    }
    evaluateRenderingState() {
        let showScene = false;
        if (this._renderingEngine.cameraEngine.camera && this._renderingEngine.show === true)
            showScene = true;
        let rendering = false;
        if (this._activeRendering === true || this._cameraChanged === true || this._sizeChanged === true)
            rendering = true;
        if (this._renderingEngine.cameraEngine.camera) {
            const camera = this._renderingEngine.cameraEngine.camera;
            if (camera.type === viewer_rendering_engine_camera_engine_1.CAMERATYPE.PERSPECTIVE) {
                const controls = camera.controls;
                if (controls.enableAutoRotation === true && controls.autoRotationSpeed !== 0)
                    return { showScene, rendering: true, blurScene: false };
            }
        }
        let blurScene = false;
        if ((this._renderingEngine.blurSceneWhenBusy && this._renderingEngine.busy) || this._renderingEngine.blur)
            blurScene = true;
        return { showScene, rendering, blurScene };
    }
    showStatistics() {
        if (this._renderingEngine.showStatistics) {
            for (let i = 0; i < this._stats.stats.length; i++)
                this._stats.stats[i].dom.style.display = '';
        }
        else {
            for (let i = 0; i < this._stats.stats.length; i++)
                this._stats.stats[i].dom.style.display = 'none';
        }
    }
    startAndStopRendering() {
        this._activeRendering = true;
    }
    startRendering() {
        this._activeRendering = true;
    }
    stopRendering() {
    }
    toggleBlur(toggle) {
        if (toggle) {
            if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1 && navigator.userAgent.toLowerCase().indexOf('android') > -1)
                return;
            this._renderingEngine.renderer.domElement.style.filter = 'blur(3px)';
        }
        else {
            this._renderingEngine.renderer.domElement.style.filter = '';
        }
    }
    toggleLogo(toggle) {
        if (this._renderingEngine.logoDivElement)
            this._renderingEngine.logoDivElement.style.display = toggle ? 'inherit' : 'none';
        if (this._renderingEngine.canvas.canvasElement)
            this._renderingEngine.canvas.canvasElement.style.display = !toggle ? 'inherit' : 'none';
    }
}
exports.RenderingManager = RenderingManager;
//# sourceMappingURL=RenderingManager.js.map