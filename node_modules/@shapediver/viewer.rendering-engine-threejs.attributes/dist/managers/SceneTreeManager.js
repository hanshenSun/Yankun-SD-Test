"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SceneTreeManager = void 0;
const THREE = __importStar(require("three"));
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const viewer_shared_math_1 = require("@shapediver/viewer.shared.math");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const viewer_rendering_engine_light_engine_1 = require("@shapediver/viewer.rendering-engine.light-engine");
const gl_matrix_1 = require("gl-matrix");
const tsyringe_1 = require("tsyringe");
const SDObject_1 = require("../types/SDObject");
const ThreejsData_1 = require("../types/ThreejsData");
class SceneTreeManager {
    constructor(_renderingEngine) {
        this._renderingEngine = _renderingEngine;
        this._eventEngine = tsyringe_1.container.resolve(viewer_shared_services_1.EventEngine);
        this._scene = new THREE.Scene();
        this._stateEngine = tsyringe_1.container.resolve(viewer_shared_services_1.StateEngine);
        this._converter = tsyringe_1.container.resolve(viewer_shared_services_1.Converter);
        this._inputValidator = tsyringe_1.container.resolve(viewer_shared_services_1.InputValidator);
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
        this._boundingBox = new viewer_shared_math_1.Box();
        this._scene.background = new THREE.Color('#ffffff');
    }
    get boundingBox() {
        return this._boundingBox;
    }
    get scene() {
        return this._scene;
    }
    collectSDTFItemData(node) {
        for (let i = 0, len = node.data.length; i < len; i++)
            if (node.data[i] instanceof viewer_shared_types_1.SDTFItemData)
                return node.data[i];
        if (!node.parent)
            return;
        return this.collectSDTFItemData(node.parent);
    }
    convertSDTFItemToVisualizationData(itemData, overview, visualizationAttributes) {
        let color = '#00fff7';
        let opacity = 1;
        let matrix = gl_matrix_1.mat4.create();
        if (visualizationAttributes['color']) {
            if (itemData.attributes['color'] && itemData.attributes['color'].typeHint === viewer_shared_types_1.PRIMITIVETYPEHINT.COLOR) {
                const colorAttribute = itemData.attributes['color'];
                const colorColorOverview = overview['color'].filter(o => o.typeHint === viewer_shared_types_1.PRIMITIVETYPEHINT.COLOR)[0];
                color = this._converter.toColor('rgb(' + colorAttribute.value + ')');
            }
        }
        if (visualizationAttributes['plotcolor']) {
            if (itemData.attributes['plotcolor'] && itemData.attributes['plotcolor'].typeHint === viewer_shared_types_1.PRIMITIVETYPEHINT.COLOR) {
                const plotcolorAttribute = itemData.attributes['plotcolor'];
                const plotcolorColorOverview = overview['plotcolor'].filter(o => o.typeHint === viewer_shared_types_1.PRIMITIVETYPEHINT.COLOR)[0];
                color = this._converter.toColor('rgb(' + plotcolorAttribute.value + ')');
            }
        }
        if (visualizationAttributes['layer']) {
            if (itemData.attributes['layer'] && itemData.attributes['layer'].typeHint === viewer_shared_types_1.PRIMITIVETYPEHINT.STRING) {
                const layerAttribute = itemData.attributes['layer'];
                const layerStringOverview = overview['layer'].filter(o => o.typeHint === viewer_shared_types_1.PRIMITIVETYPEHINT.STRING)[0];
                return viewer_shared_types_1.SDTFAttributeVisualization.stringVisualization(layerAttribute.value, layerStringOverview.values, viewer_shared_types_1.ATTRIBUTEVISUALIZATION.GRAYSCALE);
            }
        }
        return { color, opacity, matrix };
    }
    convertData(data, obj, node) {
        let dataChild = obj.children.find(oc => oc.SDid === data.id && oc.SDversion === data.version);
        if (!dataChild)
            dataChild = new SDObject_1.SDObject(data.id, data.version);
        obj.add(dataChild);
        const itemData = this.collectSDTFItemData(node);
        let visData = {
            color: '#00fff7',
            opacity: 1,
            matrix: gl_matrix_1.mat4.create()
        };
        if (itemData) {
            if (this._renderingEngine.convertSDTFItemToVisualizationData) {
                const userVisData = this._renderingEngine.convertSDTFItemToVisualizationData(itemData, this._currentSDTFOverview, this._renderingEngine.visualizationAttributes);
                try {
                    this._inputValidator.validateAndError(viewer_shared_services_1.LOGGINGTOPIC.VIEWER, `Viewer.convertSDTFItemToVisualizationData`, userVisData, 'object', true);
                    this._inputValidator.validateAndError(viewer_shared_services_1.LOGGINGTOPIC.VIEWER, `Viewer.convertSDTFItemToVisualizationData`, userVisData.opacity, 'factor', true);
                    this._inputValidator.validateAndError(viewer_shared_services_1.LOGGINGTOPIC.VIEWER, `Viewer.convertSDTFItemToVisualizationData`, userVisData.color, 'color', true);
                    this._inputValidator.validateAndError(viewer_shared_services_1.LOGGINGTOPIC.VIEWER, `Viewer.convertSDTFItemToVisualizationData`, userVisData.matrix, 'mat4', true);
                    visData.opacity = userVisData.opacity;
                    visData.color = this._converter.toColor(userVisData.color);
                    visData.matrix = visData.matrix;
                }
                catch (e) {
                    if (e instanceof viewer_shared_services_1.SDError)
                        this._logger.warn(viewer_shared_services_1.LOGGINGTOPIC.VIEWER, e.message);
                    this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.VIEWER, e, `Viewer.convertSDTFItemToVisualizationData: Encountered an error while parsing the visualization data.`, false);
                }
            }
            else {
                visData = this.convertSDTFItemToVisualizationData(itemData, this._currentSDTFOverview, this._renderingEngine.visualizationAttributes);
            }
        }
        node.transformations.push({
            id: 'sdtf',
            matrix: visData.matrix
        });
        switch (true) {
            case data instanceof viewer_shared_types_1.GeometryData:
                return this._renderingEngine.geometryLoader.load(data, dataChild, visData);
            case data instanceof ThreejsData_1.ThreejsData:
                dataChild.add(data.obj);
                break;
            case data instanceof viewer_shared_types_1.MaterialData:
                break;
            case data instanceof viewer_rendering_engine_light_engine_1.AbstractLight:
                this._renderingEngine.lightLoader.load(data, dataChild, this._scene, this._boundingBox);
                break;
            case data instanceof viewer_shared_types_1.HTMLElementAnchorData:
                break;
            default:
                break;
        }
        return new viewer_shared_math_1.Box();
    }
    init() { }
    isEmpty() {
        return ((this._boundingBox.min[0] === 0 && this._boundingBox.min[1] === 0 && this._boundingBox.min[2] === 0 &&
            this._boundingBox.max[0] === 0 && this._boundingBox.max[1] === 0 && this._boundingBox.max[2] === 0) || this._boundingBox.isEmpty());
    }
    updateSceneTree(root, lightEngine) {
        const oldBB = this._boundingBox.clone();
        this._boundingBox = new viewer_shared_math_1.Box();
        this._renderingEngine.lightLoader.shadowMapCount = 0;
        if (!this._mainNode) {
            this._mainNode = new SDObject_1.SDObject(root.id, root.version);
            this._scene.add(this._mainNode);
        }
        this._currentSDTFOverview = this._renderingEngine.createSDTFOverview();
        for (let key in this._currentSDTFOverview) {
            if (!this._renderingEngine.visualizationAttributes[key])
                this._renderingEngine.visualizationAttributes[key] = false;
        }
        for (let key in this._renderingEngine.visualizationAttributes) {
            if (!this._currentSDTFOverview[key])
                delete this._renderingEngine.visualizationAttributes[key];
        }
        this.updateNode(root, this._mainNode);
        this._boundingBox = root.boundingBox.clone();
        const lightScene = lightEngine.lightScene;
        if (lightScene) {
            const lightSceneChildren = this._mainNode.children.filter(oc => lightScene.node.id === oc.SDid);
            if (lightSceneChildren.length > 1) {
                this.updateNode(lightScene.node, lightSceneChildren[0]);
            }
            else {
                const lightSceneChild = new SDObject_1.SDObject(lightScene.node.id, lightScene.node.version);
                this._mainNode.add(lightSceneChild);
                this.updateNode(lightScene.node, lightSceneChild);
            }
        }
        if (!this._boundingBox.isEmpty())
            this._boundingBox.applyMatrix(root.nodeMatrixSDTF);
        if (!(this._boundingBox.min[0] === oldBB.min[0] && this._boundingBox.min[1] === oldBB.min[1] && this._boundingBox.min[2] === oldBB.min[2] &&
            this._boundingBox.max[0] === oldBB.max[0] && this._boundingBox.max[1] === oldBB.max[1] && this._boundingBox.max[2] === oldBB.max[2]) && !this._boundingBox.isEmpty()) {
            if (!this._stateEngine.boundingBoxCreated.resolved)
                this._stateEngine.boundingBoxCreated.resolve(true);
            this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.SCENE.SCENE_BOUNDING_BOX_CHANGE, { viewerId: this._renderingEngine.id, boundingBox: {
                    min: gl_matrix_1.vec3.clone(this._boundingBox.min),
                    max: gl_matrix_1.vec3.clone(this._boundingBox.max),
                } });
        }
        this._renderingEngine.renderingManager.evaluateTextureUnitCount(this._renderingEngine.lightLoader.shadowMapCount + this._renderingEngine.materialLoader.maxMapCount);
    }
    updateNode(node, obj) {
        if (node.excludeViewers.includes(this._renderingEngine.id))
            return;
        node.boundingBox = new viewer_shared_math_1.Box();
        for (let i = 0, len = node.data.length; i < len; i++) {
            const bb = this.convertData(node.data[i], obj, node);
            node.boundingBox.union(bb);
        }
        obj.applyTransformation(node.nodeMatrixSDTF);
        const nodeIds = [];
        for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            if (child)
                nodeIds.push(child.id);
        }
        const dataIds = node.data.map(d => d.id);
        const dataVersions = node.data.map(d => d.version);
        const childrenToRemove = obj.children.filter(oc => (!nodeIds.includes(oc.SDid)) && !(dataIds.includes(oc.SDid) && dataVersions.includes(oc.SDversion)));
        for (const objChild of childrenToRemove) {
            obj.remove(objChild);
            objChild.traverse((o) => {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
                if (o instanceof THREE.Mesh) {
                    this._renderingEngine.geometryLoader.removeFromGeometryCache(o.geometry.userData.SDid + '_' + o.geometry.userData.SDversion);
                    this._renderingEngine.materialLoader.removeFromMaterialCache(o.material.userData.SDid + '_' + o.material.userData.SDversion);
                    for (const key in o.geometry.attributes)
                        o.geometry.deleteAttribute(key);
                    o.geometry.setIndex(null);
                    o.geometry.dispose();
                    if (o.material.alphaMap)
                        (_a = o.material.alphaMap) === null || _a === void 0 ? void 0 : _a.dispose();
                    if (o.material.aoMap)
                        (_b = o.material.aoMap) === null || _b === void 0 ? void 0 : _b.dispose();
                    if (o.material.bumpMap)
                        (_c = o.material.bumpMap) === null || _c === void 0 ? void 0 : _c.dispose();
                    if (o.material.map)
                        (_d = o.material.map) === null || _d === void 0 ? void 0 : _d.dispose();
                    if (o.material.emissiveMap)
                        (_e = o.material.emissiveMap) === null || _e === void 0 ? void 0 : _e.dispose();
                    if (o.material.metalnessMap)
                        (_f = o.material.metalnessMap) === null || _f === void 0 ? void 0 : _f.dispose();
                    if (o.material.roughnessMap)
                        (_g = o.material.roughnessMap) === null || _g === void 0 ? void 0 : _g.dispose();
                    if (o.material.normalMap)
                        (_h = o.material.normalMap) === null || _h === void 0 ? void 0 : _h.dispose();
                    if (o.material.specularMap)
                        (_j = o.material.specularMap) === null || _j === void 0 ? void 0 : _j.dispose();
                    if (o.material.glossinessMap)
                        (_k = o.material.glossinessMap) === null || _k === void 0 ? void 0 : _k.dispose();
                    o.material.dispose();
                }
            });
        }
        for (let i = 0, len = node.children.length; i < len; i++) {
            const nodeChild = node.children[i];
            if (!nodeChild)
                continue;
            const objChild = obj.children.find(oc => oc.SDid === nodeChild.id);
            if (!objChild) {
                const newChild = new SDObject_1.SDObject(nodeChild.id, nodeChild.version);
                obj.add(newChild);
                this.updateNode(nodeChild, newChild);
            }
            else if (objChild.SDversion !== nodeChild.version) {
                this.updateNode(nodeChild, objChild);
            }
            if (!nodeChild.boundingBox.isEmpty())
                node.boundingBox.union(nodeChild.boundingBox);
        }
        if (!node.boundingBox.isEmpty())
            node.boundingBox.applyMatrix(node.nodeMatrixSDTF);
    }
}
exports.SceneTreeManager = SceneTreeManager;
//# sourceMappingURL=SceneTreeManager.js.map