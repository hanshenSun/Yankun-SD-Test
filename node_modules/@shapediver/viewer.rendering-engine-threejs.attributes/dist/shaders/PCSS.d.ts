export declare const main = "\n\nuniform float lightSizeUV;\nuniform float blending;\n\n#ifdef SHADOWMAP_TYPE_PCF\n\n#define NEAR_PLANE 0.1\n#define NUM_SAMPLES 20\n#define NUM_RINGS 11\n\nvec2 poissonDisk[NUM_SAMPLES];\n\nvoid initPoissonSamples( const in vec2 randomSeed ) {\n    float ANGLE_STEP = PI2 * float(NUM_RINGS) / float(NUM_SAMPLES);\n    float INV_NUM_SAMPLES = 1.0 / float(NUM_SAMPLES);\n\n    // jsfiddle that shows sample pattern: https://jsfiddle.net/a16ff1p7/\n    float angle = rand(randomSeed) * PI2;\n    float radius = INV_NUM_SAMPLES;\n    float radiusStep = radius;\n\n    for (int i = 0; i < int(NUM_SAMPLES); i++ ) {\n        poissonDisk[i] = vec2(cos(angle), sin(angle)) * pow(radius, 0.75);\n        radius += radiusStep;\n        angle += ANGLE_STEP;\n    }\n}\n\nfloat penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation\n    return (zReceiver - zBlocker) / zBlocker;\n}\n\nfloat findBlocker(sampler2D shadowMap, const in vec2 uv, const in float zReceiver ) {\n    // This uses similar triangles to compute what\n    // area of the shadow map we should search\n    float searchRadius = lightSizeUV * (zReceiver - NEAR_PLANE) / zReceiver;\n    float blockerDepthSum = 0.0;\n    int numBlockers = 0;\n\n    for (int i = 0; i < int(NUM_SAMPLES); i++ ) {\n        float shadowMapDepth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));\n        if (shadowMapDepth < zReceiver) {\n            blockerDepthSum += shadowMapDepth;\n            numBlockers++;\n        }\n    }\n\n    if (numBlockers == 0) return -1.0;\n\n    return blockerDepthSum / float(numBlockers);\n}\n\nfloat PCF_Filter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius) {\n    float sum = 0.0;\n    for (int i = 0; i < int(NUM_SAMPLES); i++ ) {\n        float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + poissonDisk[i] * filterRadius));\n        if (zReceiver <= depth) sum += 1.0;\n    }\n    for (int i = 0; i < int(NUM_SAMPLES); i++ ) {\n        float depth = unpackRGBAToDepth(texture2D(shadowMap, uv + -poissonDisk[i].yx * filterRadius));\n        if (zReceiver <= depth) sum += 1.0;\n    }\n    return sum / (2.0 * float(NUM_SAMPLES));\n}\n\nfloat PCSS(sampler2D shadowMap, vec4 coords) {\n    vec2 uv = coords.xy;\n    float zReceiver = coords.z; // Assumed to be eye-space z in this code\n\n    initPoissonSamples(uv);\n    // STEP 1: blocker search\n    float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver);\n\n    //There are no occluders so early out (this saves filtering)\n    if (avgBlockerDepth == -1.0) return 1.0;\n\n    // STEP 2: penumbra size\n    float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\n    float filterRadius = penumbraRatio * lightSizeUV * NEAR_PLANE / zReceiver;\n\n    // STEP 3: filtering\n    //return avgBlockerDepth;\n    return PCF_Filter(shadowMap, uv, zReceiver, filterRadius);\n}\n#endif\n";
export declare const entry = "\n// PCSS implementation\nvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\nfloat dx = texelSize.x;\nfloat dy = texelSize.y;\nvec2 uv = shadowCoord.xy;\nvec2 f = fract( uv * shadowMapSize + 0.5 );\nuv -= f * texelSize;\nfloat shadow1 = (\n    texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n    texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n    mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n         texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n         f.x ) +\n    mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n         texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n         f.x ) +\n    mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n         texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n         f.y ) +\n    mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n         texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n         f.y ) +\n    mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n              texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n              f.x ),\n         mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n              texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n              f.x ),\n         f.y )\n) * ( 1.0 / 9.0 );\nfloat shadow2 = PCSS( shadowMap, shadowCoord );\nshadow = shadow1 * (1.0 - blending) + blending * shadow2;\n            ";
//# sourceMappingURL=PCSS.d.ts.map