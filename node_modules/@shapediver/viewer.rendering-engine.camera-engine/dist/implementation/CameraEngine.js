"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CameraEngine = void 0;
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const tsyringe_1 = require("tsyringe");
const viewer_shared_math_1 = require("@shapediver/viewer.shared.math");
const ICameraEngine_1 = require("../interfaces/ICameraEngine");
const PerspectiveCamera_1 = require("./camera/PerspectiveCamera");
const OrthographicCamera_1 = require("./camera/OrthographicCamera");
const gl_matrix_1 = require("gl-matrix");
class CameraEngine {
    constructor(_viewerId, _canvas, _domEventEngine) {
        this._viewerId = _viewerId;
        this._canvas = _canvas;
        this._domEventEngine = _domEventEngine;
        this._cameras = {};
        this._camerasDomEventListenerToken = {};
        this._uuidGenerator = tsyringe_1.container.resolve(viewer_shared_services_1.UuidGenerator);
        this._settingsEngine = tsyringe_1.container.resolve(viewer_shared_services_1.SettingsEngine);
        this._stateEngine = tsyringe_1.container.resolve(viewer_shared_services_1.StateEngine);
        this._eventEngine = tsyringe_1.container.resolve(viewer_shared_services_1.EventEngine);
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
        this._boundingBox = new viewer_shared_math_1.Box();
        this._camera = null;
        this._settingsApplied = false;
        this._eventEngine.addListener(viewer_shared_services_1.EVENTTYPE.SCENE.SCENE_BOUNDING_BOX_CHANGE, (e) => {
            const viewerEvent = e;
            if (viewerEvent.viewerId === this._viewerId) {
                this._boundingBox = new viewer_shared_math_1.Box(viewerEvent.boundingBox.min, viewerEvent.boundingBox.max);
                for (let c in this._cameras)
                    this._cameras[c].boundingBox = this._boundingBox.clone();
            }
        });
    }
    get camera() {
        return this._camera;
    }
    get cameras() {
        return this._cameras;
    }
    applySettings() {
        for (let id in this._settingsEngine.settings.camera.cameras) {
            const cameraSetting = this._settingsEngine.settings.camera.cameras[id];
            if (cameraSetting.type === 'perspective') {
                this.createCamera(ICameraEngine_1.CAMERATYPE.PERSPECTIVE, id);
            }
            else {
                const camera = this.createCamera(ICameraEngine_1.CAMERATYPE.ORTHOGRAPHIC, id);
                camera.direction = cameraSetting.type;
            }
        }
        if (this._cameras[this._settingsEngine.settings.camera.cameraId] && this._settingsEngine.settings.camera.cameraId !== 'standard')
            this.removeCamera('standard');
        this.assignCamera(this._settingsEngine.settings.camera.cameraId);
        for (let c in this._cameras)
            this._cameras[c].applySettings();
        this._settingsApplied = true;
    }
    assignCamera(id) {
        const camera = this._cameras[id];
        if (!camera)
            return;
        this._camera = camera;
    }
    createCamera(type, id) {
        const cameraId = id || this._uuidGenerator.create();
        if (this._cameras[cameraId]) {
            const error = new viewer_shared_services_1.SDError(`Camera: Camera (${type}) with this id (${cameraId}) already exists.`);
            this._logger.warn(viewer_shared_services_1.LOGGINGTOPIC.CAMERA, error.message);
            throw error;
        }
        if (ICameraEngine_1.CAMERATYPE.ORTHOGRAPHIC === type) {
            const camera = new OrthographicCamera_1.OrthographicCamera(this._viewerId, cameraId, this._canvas.canvasElement);
            this._camerasDomEventListenerToken[cameraId] = this._domEventEngine.addDomEventListener(camera.controls.cameraControlsEventDistribution);
            this._cameras[cameraId] = camera;
            camera.boundingBox = this._boundingBox.clone();
            if (this._settingsApplied) {
                camera.applySettings();
            }
            else {
                camera.zoomTo(undefined, { duration: 0 });
            }
            return camera;
        }
        else {
            const camera = new PerspectiveCamera_1.PerspectiveCamera(this._viewerId, cameraId, this._canvas.canvasElement);
            this._camerasDomEventListenerToken[cameraId] = this._domEventEngine.addDomEventListener(camera.controls.cameraControlsEventDistribution);
            this._cameras[cameraId] = camera;
            camera.boundingBox = this._boundingBox.clone();
            if (this._settingsApplied) {
                camera.applySettings();
            }
            else {
                camera.zoomTo(undefined, { duration: 0 });
            }
            return camera;
        }
    }
    removeCamera(id) {
        const camera = this._cameras[id];
        if (!camera)
            return false;
        this._domEventEngine.removeDomEventListener(this._camerasDomEventListenerToken[id]);
        if (this._camera && this._camera.id === id)
            this._camera = null;
        delete this._cameras[id];
        delete this._camerasDomEventListenerToken[id];
        return true;
    }
    saveSettings() {
        for (let c in this._cameras) {
            const camera = this._cameras[c];
            if (camera.type === ICameraEngine_1.CAMERATYPE.PERSPECTIVE) {
                const controls = camera.controls;
                this._settingsEngine.camera.cameras[c] = {
                    autoAdjust: camera.autoAdjust,
                    cameraMovementDuration: camera.cameraMovementDuration,
                    enableCameraControls: camera.enableCameraControls,
                    revertAtMouseUp: camera.revertAtMouseUp,
                    revertAtMouseUpDuration: camera.revertAtMouseUpDuration,
                    zoomExtentsFactor: camera.zoomExtentsFactor,
                    position: { x: camera.defaultPosition[0], y: camera.defaultPosition[1], z: camera.defaultPosition[2] },
                    target: { x: camera.defaultTarget[0], y: camera.defaultTarget[1], z: camera.defaultTarget[2] },
                    type: camera.type,
                    fov: camera.fov,
                    controls: {
                        autoRotationSpeed: controls.autoRotationSpeed,
                        damping: controls.damping,
                        enableAutoRotation: controls.enableAutoRotation,
                        enableKeyPan: controls.enableKeyPan,
                        enablePan: controls.enablePan,
                        enableRotation: controls.enableRotation,
                        enableZoom: controls.enableZoom,
                        input: controls.input,
                        keyPanSpeed: controls.keyPanSpeed,
                        movementSmoothness: controls.movementSmoothness,
                        rotationSpeed: controls.rotationSpeed,
                        panSpeed: controls.panSpeed,
                        zoomSpeed: controls.zoomSpeed,
                        restrictions: {
                            position: {
                                cube: {
                                    min: { x: controls.cubePositionRestriction.min[0], y: controls.cubePositionRestriction.min[1], z: controls.cubePositionRestriction.min[2] },
                                    max: { x: controls.cubePositionRestriction.max[0], y: controls.cubePositionRestriction.max[1], z: controls.cubePositionRestriction.max[2] },
                                },
                                sphere: {
                                    center: { x: controls.spherePositionRestriction.center[0], y: controls.spherePositionRestriction.center[1], z: controls.spherePositionRestriction.center[2] },
                                    radius: controls.spherePositionRestriction.radius,
                                },
                            },
                            target: {
                                cube: {
                                    min: { x: controls.cubeTargetRestriction.min[0], y: controls.cubeTargetRestriction.min[1], z: controls.cubeTargetRestriction.min[2] },
                                    max: { x: controls.cubeTargetRestriction.max[0], y: controls.cubeTargetRestriction.max[1], z: controls.cubeTargetRestriction.max[2] },
                                },
                                sphere: {
                                    center: { x: controls.sphereTargetRestriction.center[0], y: controls.sphereTargetRestriction.center[1], z: controls.sphereTargetRestriction.center[2] },
                                    radius: controls.sphereTargetRestriction.radius,
                                },
                            },
                            rotation: controls.rotationRestriction,
                            zoom: controls.zoomRestriction,
                        }
                    }
                };
            }
            else {
                if (this._settingsEngine.camera.cameras[camera.id]) {
                    const previousDirection = this._settingsEngine.camera.cameras[camera.id].type;
                    if (previousDirection !== camera.type && (this._settingsEngine.camera.cameras[camera.id].position.x === camera.defaultPosition[0] &&
                        this._settingsEngine.camera.cameras[camera.id].position.y === camera.defaultPosition[1] &&
                        this._settingsEngine.camera.cameras[camera.id].position.z === camera.defaultPosition[2] &&
                        this._settingsEngine.camera.cameras[camera.id].target.x === camera.defaultTarget[0] &&
                        this._settingsEngine.camera.cameras[camera.id].target.y === camera.defaultTarget[1] &&
                        this._settingsEngine.camera.cameras[camera.id].target.z === camera.defaultTarget[2])) {
                        camera.defaultPosition = gl_matrix_1.vec3.clone(camera.position);
                        camera.defaultTarget = gl_matrix_1.vec3.clone(camera.target);
                    }
                }
                const controls = camera.controls;
                this._settingsEngine.camera.cameras[c] = {
                    autoAdjust: camera.autoAdjust,
                    cameraMovementDuration: camera.cameraMovementDuration,
                    enableCameraControls: camera.enableCameraControls,
                    revertAtMouseUp: camera.revertAtMouseUp,
                    revertAtMouseUpDuration: camera.revertAtMouseUpDuration,
                    zoomExtentsFactor: camera.zoomExtentsFactor,
                    position: { x: camera.defaultPosition[0], y: camera.defaultPosition[1], z: camera.defaultPosition[2] },
                    target: { x: camera.defaultTarget[0], y: camera.defaultTarget[1], z: camera.defaultTarget[2] },
                    type: camera.type,
                    controls: {
                        damping: controls.damping,
                        enableKeyPan: controls.enableKeyPan,
                        enablePan: controls.enablePan,
                        enableZoom: controls.enableZoom,
                        input: controls.input,
                        keyPanSpeed: controls.keyPanSpeed,
                        movementSmoothness: controls.movementSmoothness,
                        panSpeed: controls.panSpeed,
                        zoomSpeed: controls.zoomSpeed,
                    }
                };
            }
        }
    }
}
exports.CameraEngine = CameraEngine;
//# sourceMappingURL=CameraEngine.js.map