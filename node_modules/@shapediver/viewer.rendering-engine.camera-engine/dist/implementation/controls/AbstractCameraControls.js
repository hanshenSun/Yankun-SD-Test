"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AbstractCameraControls = void 0;
const gl_matrix_1 = require("gl-matrix");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const tsyringe_1 = require("tsyringe");
const CameraInterpolationManager_1 = require("../interpolation/CameraInterpolationManager");
class AbstractCameraControls {
    constructor(_viewerId, _camera, _canvas, _enabled, type) {
        this._viewerId = _viewerId;
        this._camera = _camera;
        this._canvas = _canvas;
        this._enabled = _enabled;
        this._eventEngine = tsyringe_1.container.resolve(viewer_shared_services_1.EventEngine);
        this._manualInteraction = false;
        this._moving = false;
        this._movingDuration = 0;
        this._nonmanualInteraction = false;
        this._position = gl_matrix_1.vec3.create();
        this._target = gl_matrix_1.vec3.create();
        this._cameraInterpolationManager = new CameraInterpolationManager_1.CameraInterpolationManager(this._camera, this);
        this._manualInteractionTransformations = { position: [], target: [] };
        this._nonmanualInteractionTransformations = { position: [], target: [] };
    }
    get cameraControlsEventDistribution() {
        return this._cameraControlsEventDistribution;
    }
    get canvas() {
        return this._canvas;
    }
    set canvas(value) {
        this._canvas = value;
    }
    get enabled() {
        return this._enabled;
    }
    set enabled(value) {
        if (!value) {
            this._manualInteraction = false;
            this._manualInteractionTransformations = { position: [], target: [] };
            this._nonmanualInteraction = false;
            this._nonmanualInteractionTransformations = { position: [], target: [] };
            this._cameraControlsEventDistribution.reset();
            this._cameraLogic.reset();
        }
        this._enabled = value;
    }
    get camera() {
        return this._camera;
    }
    set camera(value) {
        this._camera = value;
    }
    get position() {
        return this._position;
    }
    set position(value) {
        this._position = value;
    }
    get target() {
        return this._target;
    }
    set target(value) {
        this._target = value;
    }
    animate(path, options) {
        if (options && options.duration === 0) {
            this._position = path[path.length - 1].position;
            this._target = path[path.length - 1].target;
            return new Promise(resolve => resolve(true));
        }
        this._manualInteraction = false;
        this._manualInteractionTransformations = { position: [], target: [] };
        return this._cameraInterpolationManager.interpolate(path, options);
    }
    applyPositionVector(vector, manualInteraction) {
        if (this._manualInteraction || manualInteraction) {
            this._manualInteraction = true;
            this._manualInteractionTransformations.position.push({ vector });
        }
        else {
            this._nonmanualInteraction = true;
            this._nonmanualInteractionTransformations.position.push({ vector });
        }
    }
    applyTargetVector(vector, manualInteraction) {
        if (this._manualInteraction || manualInteraction) {
            this._manualInteraction = true;
            this._manualInteractionTransformations.target.push({ vector });
        }
        else {
            this._nonmanualInteraction = true;
            this._nonmanualInteractionTransformations.target.push({ vector });
        }
    }
    applyPositionMatrix(matrix, manualInteraction) {
        if (this._manualInteraction || manualInteraction) {
            this._manualInteraction = true;
            this._manualInteractionTransformations.position.push({ matrix });
        }
        else {
            this._nonmanualInteraction = true;
            this._nonmanualInteractionTransformations.position.push({ matrix });
        }
    }
    applyTargetMatrix(matrix, manualInteraction) {
        if (this._manualInteraction || manualInteraction) {
            this._manualInteraction = true;
            this._manualInteractionTransformations.target.push({ matrix });
        }
        else {
            this._nonmanualInteraction = true;
            this._nonmanualInteractionTransformations.target.push({ matrix });
        }
    }
    applyUpMatrix(matrix, manualInteraction) {
        throw new Error("Method not implemented.");
    }
    getPositionWithManualUpdates() {
        let position = gl_matrix_1.vec3.clone(this._position);
        if (this._manualInteraction) {
            for (let i = this._manualInteractionTransformations.position.length - 1; i >= 0; i--) {
                if (this._manualInteractionTransformations.position[i].matrix) {
                    position = gl_matrix_1.vec3.transformMat4(position, position, this._manualInteractionTransformations.position[i].matrix);
                }
                else {
                    position = gl_matrix_1.vec3.add(position, position, this._manualInteractionTransformations.position[i].vector);
                }
            }
        }
        return position;
    }
    getTargetWithManualUpdates() {
        let target = gl_matrix_1.vec3.clone(this._target);
        if (this._manualInteraction) {
            for (let i = this._manualInteractionTransformations.target.length - 1; i >= 0; i--) {
                if (this._manualInteractionTransformations.target[i].matrix) {
                    target = gl_matrix_1.vec3.transformMat4(target, target, this._manualInteractionTransformations.target[i].matrix);
                }
                else {
                    target = gl_matrix_1.vec3.add(target, target, this._manualInteractionTransformations.target[i].vector);
                }
            }
        }
        return target;
    }
    getPositionWithUpdates() {
        return this.getPosition();
    }
    getTargetWithUpdates() {
        return this.getTarget();
    }
    isMoving() {
        return this._manualInteraction || this._nonmanualInteraction;
    }
    isWithinRestrictions(position, target) {
        return this._cameraLogic.isWithinRestrictions(position, target);
    }
    reset() {
        this._cameraControlsEventDistribution.reset();
        this._cameraLogic.reset();
    }
    update(time) {
        if (!this._enabled)
            return { position: gl_matrix_1.vec3.clone(this._position), target: gl_matrix_1.vec3.clone(this._target) };
        if (this._manualInteraction === true && this._cameraInterpolationManager.active())
            this._cameraInterpolationManager.stop();
        let { position, target } = this._cameraLogic.restrict(this.getPosition(), this.getTarget());
        this._position = gl_matrix_1.vec3.clone(position);
        this._target = gl_matrix_1.vec3.clone(target);
        this._manualInteraction = false;
        this._manualInteractionTransformations = { position: [], target: [] };
        this._nonmanualInteraction = this._cameraInterpolationManager.active();
        this._nonmanualInteractionTransformations = { position: [], target: [] };
        this._cameraLogic.update(time, this._nonmanualInteraction);
        const oldMovement = this._moving;
        const cameraDefinition = {
            position: gl_matrix_1.vec3.clone(this._position),
            target: gl_matrix_1.vec3.clone(this._target)
        };
        this._movingDuration += time;
        this._moving = (this._manualInteraction || this._nonmanualInteraction);
        switch (true) {
            case oldMovement !== this._moving && this._moving === true:
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.CAMERA.CAMERA_START, { viewerId: this._viewerId, cameraId: this.camera.id });
                break;
            case oldMovement !== this._moving && this._moving === false:
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.CAMERA.CAMERA_END, { viewerId: this._viewerId, cameraId: this.camera.id });
                break;
            default:
                this._eventEngine.emitEvent(viewer_shared_services_1.EVENTTYPE.CAMERA.CAMERA_MOVE, { viewerId: this._viewerId, cameraId: this.camera.id });
        }
        if (!this._moving)
            this._movingDuration = 0;
        return cameraDefinition;
    }
    getPosition() {
        let position = gl_matrix_1.vec3.clone(this._position);
        if (this._manualInteraction) {
            for (let i = this._manualInteractionTransformations.position.length - 1; i >= 0; i--) {
                if (this._manualInteractionTransformations.position[i].matrix) {
                    position = gl_matrix_1.vec3.transformMat4(position, position, this._manualInteractionTransformations.position[i].matrix);
                }
                else {
                    position = gl_matrix_1.vec3.add(position, position, this._manualInteractionTransformations.position[i].vector);
                }
            }
        }
        else if (this._nonmanualInteraction) {
            for (let i = this._nonmanualInteractionTransformations.position.length - 1; i >= 0; i--) {
                if (this._nonmanualInteractionTransformations.position[i].matrix) {
                    position = gl_matrix_1.vec3.transformMat4(position, position, this._nonmanualInteractionTransformations.position[i].matrix);
                }
                else {
                    position = gl_matrix_1.vec3.add(position, position, this._nonmanualInteractionTransformations.position[i].vector);
                }
            }
        }
        return position;
    }
    getTarget() {
        let target = gl_matrix_1.vec3.clone(this._target);
        if (this._manualInteraction) {
            for (let i = this._manualInteractionTransformations.target.length - 1; i >= 0; i--) {
                if (this._manualInteractionTransformations.target[i].matrix) {
                    target = gl_matrix_1.vec3.transformMat4(target, target, this._manualInteractionTransformations.target[i].matrix);
                }
                else {
                    target = gl_matrix_1.vec3.add(target, target, this._manualInteractionTransformations.target[i].vector);
                }
            }
        }
        else if (this._nonmanualInteraction) {
            for (let i = this._nonmanualInteractionTransformations.target.length - 1; i >= 0; i--) {
                if (this._nonmanualInteractionTransformations.target[i].matrix) {
                    target = gl_matrix_1.vec3.transformMat4(target, target, this._nonmanualInteractionTransformations.target[i].matrix);
                }
                else {
                    target = gl_matrix_1.vec3.add(target, target, this._nonmanualInteractionTransformations.target[i].vector);
                }
            }
        }
        return target;
    }
}
exports.AbstractCameraControls = AbstractCameraControls;
//# sourceMappingURL=AbstractCameraControls.js.map