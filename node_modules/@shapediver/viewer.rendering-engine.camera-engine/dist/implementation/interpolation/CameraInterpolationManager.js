"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CameraInterpolationManager = void 0;
const TWEEN = __importStar(require("@tweenjs/tween.js"));
const CameraMultipleInterpolation_1 = require("./interpolationMethods/CameraMultipleInterpolation");
const CameraSphericalInterpolation_1 = require("./interpolationMethods/CameraSphericalInterpolation");
const CameraLinearInterpolation_1 = require("./interpolationMethods/CameraLinearInterpolation");
const CameraCylindricalInterpolation_1 = require("./interpolationMethods/CameraCylindricalInterpolation");
class CameraInterpolationManager {
    constructor(_camera, _cameraControls) {
        this._camera = _camera;
        this._cameraControls = _cameraControls;
        this.TweenWrapper = class {
            constructor(options, cb, onComplete) {
                this._properties = { delta: 0 };
                this._tween = new TWEEN.Tween(this._properties);
                this._tween.easing(options.easing);
                this._tween.to({ delta: 1.0 }, options.duration);
                this._tween.onUpdate((v) => {
                    cb.onUpdate(v);
                });
                this._tween.onStop((v) => {
                    if (cb.onStop)
                        cb.onStop(v);
                    this._resolve(true);
                });
                this._tween.onComplete((v) => {
                    if (cb.onComplete)
                        cb.onComplete(v);
                    onComplete();
                    this._resolve(true);
                });
            }
            start() {
                return new Promise((resolve) => {
                    this._resolve = resolve;
                    this._tween.start();
                });
            }
            stop() {
                this._tween.stop();
            }
        };
    }
    active() {
        return this._tween ? true : false;
    }
    interpolate(path, options = {}) {
        const newPath = [];
        for (let i = 0; i < path.length; i++)
            newPath.push({
                position: path[i].position,
                target: path[i].target,
            });
        if (this._tween) {
            this._tween.stop();
            this._tween = null;
        }
        let parsedOptions = this.optionsParser(options);
        this._tween = new this.TweenWrapper(parsedOptions, newPath.length === 2 ?
            this.getCameraInterpolation(newPath[0], newPath[1], parsedOptions.coordinates) :
            new CameraMultipleInterpolation_1.CameraMultipleInterpolation(this._camera, this._cameraControls, newPath, parsedOptions.interpolation), () => { this._tween = null; });
        return this._tween.start();
    }
    stop() {
        if (this._tween)
            this._tween.stop();
        this._tween = null;
    }
    getCameraInterpolation(from, to, type) {
        switch (type) {
            case 'linear':
                return new CameraLinearInterpolation_1.CameraLinearInterpolation(this._camera, this._cameraControls, from, to);
            case 'spherical':
                return new CameraSphericalInterpolation_1.CameraSphericalInterpolation(this._camera, this._cameraControls, from, to);
            case 'cylindrical':
                return new CameraCylindricalInterpolation_1.CameraCylindricalInterpolation(this._camera, this._cameraControls, from, to);
            default:
                return new CameraMultipleInterpolation_1.CameraMultipleInterpolation(this._camera, this._cameraControls, [from, to], TWEEN.Interpolation.CatmullRom);
        }
    }
    optionsParser(options) {
        let easing = TWEEN.Easing.Quartic.InOut;
        if (typeof options.easing === 'string') {
            const keys = options.easing.split('.');
            const easingFamily = TWEEN.Easing[keys[0]];
            if (easingFamily) {
                const easingFunction = easingFamily[keys[1]];
                if (easingFunction)
                    easing = easingFunction;
            }
        }
        else if (typeof options.easing === 'function') {
            easing = options.easing;
        }
        let interpolation = TWEEN.Interpolation.CatmullRom;
        if (typeof options.interpolation === 'string') {
            const interpolationFunction = TWEEN.Interpolation[options.interpolation];
            if (interpolationFunction && interpolationFunction !== TWEEN.Interpolation.Utils)
                interpolation = interpolationFunction;
        }
        else if (typeof options.interpolation === 'function') {
            interpolation = options.interpolation;
        }
        return {
            default: options.default || false,
            duration: options.duration && options.duration >= 0 ? options.duration : 0,
            easing,
            coordinates: options.coordinates !== 'spherical' && options.coordinates !== 'linear' && options.coordinates !== 'cylindrical' ? 'cylindrical' : options.coordinates,
            interpolation
        };
    }
}
exports.CameraInterpolationManager = CameraInterpolationManager;
//# sourceMappingURL=CameraInterpolationManager.js.map