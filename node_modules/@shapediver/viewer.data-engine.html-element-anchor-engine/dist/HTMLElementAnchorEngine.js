"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HTMLElementAnchorEngine = void 0;
const tsyringe_1 = require("tsyringe");
const viewer_shared_types_1 = require("@shapediver/viewer.shared.types");
const viewer_shared_node_tree_1 = require("@shapediver/viewer.shared.node-tree");
const viewer_shared_services_1 = require("@shapediver/viewer.shared.services");
const viewer_shared_math_1 = require("@shapediver/viewer.shared.math");
let HTMLElementAnchorEngine = class HTMLElementAnchorEngine {
    constructor() {
        this._logger = tsyringe_1.container.resolve(viewer_shared_services_1.Logger);
        this._converter = tsyringe_1.container.resolve(viewer_shared_services_1.Converter);
    }
    loadContent(content) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const data = content.data;
                const node = new viewer_shared_node_tree_1.TreeNode('htmlElementAnchors');
                if (content.format === 'tag2d') {
                    data.forEach((element) => {
                        if (!element.location || !element.text) {
                            this._logger.warn(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, 'HTMLElementAnchorEngine.load: One of the specified Tag2D elements did not have all necessary properties.');
                            return;
                        }
                        node.data.push(new viewer_shared_types_1.HTMLElementAnchorData(this._converter.toVec3(element.location), { color: this._converter.toColor(element.color, '#000000'), text: element.text }, 'text'));
                    });
                }
                else if (content.format === 'anchor') {
                    data.forEach((element) => {
                        if (!element.location || !element.data) {
                            this._logger.warn(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, 'HTMLElementAnchorEngine.load: One of the specified Anchor elements did not have all necessary properties.');
                            return;
                        }
                        let position;
                        if (element.data.position)
                            position = {
                                vertical: element.data.position.vertical,
                                horizontal: element.data.position.horizontal
                            };
                        let intersectionTarget;
                        if (element.intersectionTarget) {
                            if (typeof element.intersectionTarget === 'string' || Array.isArray(element.intersectionTarget)) {
                                intersectionTarget = element.intersectionTarget;
                            }
                            else if (element.intersectionTarget.min && element.intersectionTarget.max) {
                                intersectionTarget = new viewer_shared_math_1.Box(this._converter.toVec3(element.intersectionTarget.min), this._converter.toVec3(element.intersectionTarget.max));
                            }
                        }
                        if (!element.format || (element.format === 'text')) {
                            if (!element.data.text) {
                                this._logger.warn(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, 'HTMLElementAnchorEngine.load: The text property for an Anchor element is missing.');
                                return;
                            }
                            const textData = element.data;
                            node.data.push(new viewer_shared_types_1.HTMLElementAnchorData(this._converter.toVec3(element.location), {
                                color: this._converter.toColor(textData.color, '#000000'),
                                text: textData.text,
                                hidden: textData.hidden,
                                textAlign: textData.textAlign,
                                position
                            }, 'text', element.hideable, element.viewports, intersectionTarget));
                        }
                        else if (element.format === 'image') {
                            if (!element.data.src || !element.data.width || !element.data.height || !element.data.alt) {
                                this._logger.warn(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, 'HTMLElementAnchorEngine.load: One of the specified Anchor elements did not have all necessary properties.');
                                return;
                            }
                            const imageData = element.data;
                            node.data.push(new viewer_shared_types_1.HTMLElementAnchorData(this._converter.toVec3(element.location), {
                                alt: imageData.alt,
                                height: typeof imageData.height === 'string' ? +imageData.height : imageData.height,
                                width: typeof imageData.width === 'string' ? +imageData.width : imageData.width,
                                src: imageData.src,
                                hidden: imageData.hidden,
                                position
                            }, 'image', element.hideable, element.viewports, intersectionTarget));
                        }
                        this._logger.warn(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, `HTMLElementAnchorEngine.load: The Anchor does not have a recognized format: ${element.format}`);
                    });
                }
                return node;
            }
            catch (e) {
                this._logger.error(viewer_shared_services_1.LOGGINGTOPIC.DATAPROCESSING, e, 'HTMLElementAnchorEngine.load: Loading of anchors failed.');
                return new viewer_shared_node_tree_1.TreeNode();
            }
        });
    }
};
HTMLElementAnchorEngine = __decorate([
    tsyringe_1.singleton()
], HTMLElementAnchorEngine);
exports.HTMLElementAnchorEngine = HTMLElementAnchorEngine;
//# sourceMappingURL=HTMLElementAnchorEngine.js.map