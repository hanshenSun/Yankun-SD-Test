"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Converter = void 0;
const gl_matrix_1 = require("gl-matrix");
const tinycolor_1 = require("@ctrl/tinycolor");
const tsyringe_1 = require("tsyringe");
const SDError_1 = require("../logger/SDError");
let Converter = class Converter {
    tinyColorToString(color) {
        return color.toHexString();
    }
    toHex8Color(color, defColorString = '#00fff7') {
        const c = this.toColor(color, defColorString);
        const tColor = new tinycolor_1.TinyColor(c);
        const cH8 = tColor.toHex8String();
        return cH8.replace('#', '0x');
    }
    toColorArray(color) {
        const tColor = new tinycolor_1.TinyColor(color);
        const rgb = tColor.toRgb();
        return [rgb.r / 255.0, rgb.g / 255.0, rgb.b / 255.0];
    }
    combineImages(redChannel, greenChannel, blueChannel) {
        if (!redChannel && !greenChannel && !blueChannel)
            throw new SDError_1.SDError('No channels provided.');
        if (redChannel && greenChannel && blueChannel) {
            if (redChannel.width !== greenChannel.width || redChannel.width !== blueChannel.width || redChannel.height !== greenChannel.height || redChannel.height !== blueChannel.height)
                throw new SDError_1.SDError('Image sizes are different.');
            const image = redChannel;
            const canvas = document.createElement("canvas");
            canvas.width = image.width;
            canvas.height = image.height;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(image, 0, 0);
            const imageDataR = ctx.getImageData(0, 0, canvas.width, canvas.height);
            ctx.drawImage(greenChannel, 0, 0);
            const imageDataG = ctx.getImageData(0, 0, canvas.width, canvas.height);
            ctx.drawImage(blueChannel, 0, 0);
            const imageDataB = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageDataR.data.length; i += 4) {
                imageDataR.data[i + 1] = imageDataG.data[i + 1];
                imageDataR.data[i + 2] = imageDataB.data[i + 2];
            }
            ctx.putImageData(imageDataR, 0, 0);
            const resultImage = document.createElement('img');
            resultImage.src = canvas.toDataURL();
            return resultImage;
        }
        else if (redChannel && blueChannel || redChannel && greenChannel || blueChannel && greenChannel) {
            let mainImage, secondImage;
            if (!greenChannel) {
                mainImage = redChannel;
                secondImage = blueChannel;
            }
            else if (!blueChannel) {
                mainImage = redChannel;
                secondImage = greenChannel;
            }
            else {
                mainImage = greenChannel;
                secondImage = blueChannel;
            }
            if (mainImage.width !== secondImage.width || mainImage.height !== secondImage.height)
                throw new SDError_1.SDError('Image sizes are different.');
            const image = mainImage;
            const canvas = document.createElement("canvas");
            canvas.width = image.width;
            canvas.height = image.height;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(image, 0, 0);
            const imageDataMain = ctx.getImageData(0, 0, canvas.width, canvas.height);
            ctx.drawImage(mainImage, 0, 0);
            const imageDataSecond = ctx.getImageData(0, 0, canvas.width, canvas.height);
            ctx.drawImage(secondImage, 0, 0);
            for (let i = 0; i < imageDataMain.data.length; i += 4) {
                if (!redChannel) {
                    imageDataMain.data[i + 0] = 0;
                    imageDataMain.data[i + 2] = imageDataSecond.data[i + 2];
                }
                if (!greenChannel) {
                    imageDataMain.data[i + 1] = 0;
                    imageDataMain.data[i + 2] = imageDataSecond.data[i + 2];
                }
                if (!blueChannel) {
                    imageDataMain.data[i + 1] = imageDataSecond.data[i + 2];
                    imageDataMain.data[i + 2] = 0;
                }
            }
            ctx.putImageData(imageDataMain, 0, 0);
            const resultImage = document.createElement('img');
            resultImage.src = canvas.toDataURL();
            return resultImage;
        }
        else {
            const image = (redChannel || blueChannel || greenChannel);
            const canvas = document.createElement("canvas");
            canvas.width = image.width;
            canvas.height = image.height;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(image, 0, 0);
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < imageData.data.length; i += 4) {
                if (redChannel) {
                    imageData.data[i + 1] = 0;
                    imageData.data[i + 2] = 0;
                }
                if (greenChannel) {
                    imageData.data[i + 0] = 0;
                    imageData.data[i + 2] = 0;
                }
                if (blueChannel) {
                    imageData.data[i + 0] = 0;
                    imageData.data[i + 1] = 0;
                }
            }
            ctx.putImageData(imageData, 0, 0);
            const resultImage = document.createElement('img');
            resultImage.src = canvas.toDataURL();
            return resultImage;
        }
    }
    toColor(color, defColorString = '#00fff7') {
        if (!color || color === 'default')
            return defColorString;
        if (color.constructor === Float32Array)
            color = Array.from(color);
        const tColor = new tinycolor_1.TinyColor(color);
        if (color instanceof tinycolor_1.TinyColor)
            return this.tinyColorToString(tColor);
        if (typeof color === 'number') {
            let cs = color.toString(16);
            let cl = cs.length;
            if (cl < 3)
                cs = cs.padStart(3, '0');
            else if (cl < 6)
                cs = cs.padStart(6, '0');
            else if (cl < 8)
                cs = cs.padEnd(8, '0');
            let tc = new tinycolor_1.TinyColor(cs);
            return tc.isValid ? this.tinyColorToString(tc) : defColorString;
        }
        if (color.isColor && typeof color.getHexString == 'function') {
            let tc = new tinycolor_1.TinyColor(color.getHexString());
            return tc.isValid ? this.tinyColorToString(tc) : defColorString;
        }
        if (Array.isArray(color) && (color.length == 3 || color.length == 4)) {
            let isRGBArray = true;
            for (let i = 0; i < 3; ++i) {
                color[i] = parseFloat(color[i]);
                if (isNaN(color[i])) {
                    isRGBArray = false;
                }
            }
            if (!isRGBArray)
                return defColorString;
            let tc = new tinycolor_1.TinyColor({
                r: Math.max(0, Math.min(color[0], 255)),
                g: Math.max(0, Math.min(color[1], 255)),
                b: Math.max(0, Math.min(color[2], 255))
            });
            if (color.length == 4) {
                let a = parseFloat(color[3]);
                if (!isNaN(a)) {
                    tc.setAlpha(Math.max(0, Math.min(a, 255)) / 255);
                }
            }
            return tc.isValid ? this.tinyColorToString(tc) : defColorString;
        }
        if (typeof color !== 'string') {
            let tc = new tinycolor_1.TinyColor(color);
            return tc.isValid ? this.tinyColorToString(tc) : defColorString;
        }
        var tmpColor = color.replace('0x', '#');
        if (tmpColor.match(/^#[a-f0-9]{6}$/i) !== null) {
            let tc = new tinycolor_1.TinyColor(tmpColor + 'ff');
            return tc.isValid ? this.tinyColorToString(tc) : defColorString;
        }
        if (tmpColor.match(/^#[a-f0-9]{8}$/i) !== null) {
            let tc = new tinycolor_1.TinyColor(tmpColor);
            return tc.isValid ? this.tinyColorToString(tc) : defColorString;
        }
        if (tmpColor.match(/^#[a-f0-9]{7}$/i) !== null) {
            let tc = new tinycolor_1.TinyColor(tmpColor.slice(0, 7) + '0' + tmpColor.slice(-1));
            return tc.isValid ? this.tinyColorToString(tc) : defColorString;
        }
        let tc = new tinycolor_1.TinyColor(tmpColor);
        return tc.isValid ? this.tinyColorToString(tc) : defColorString;
    }
    toVec3(point) {
        if (Array.isArray(point) && point.length >= 3 && typeof point[0] === 'number' && typeof point[1] === 'number' && typeof point[2] === 'number')
            return gl_matrix_1.vec3.fromValues(point[0], point[1], point[2]);
        if (((point.x || point.x === 0) && typeof point.x === 'number') && ((point.y || point.y === 0) && typeof point.y === 'number') && ((point.z || point.z === 0) && typeof point.z === 'number'))
            return gl_matrix_1.vec3.fromValues(point.x, point.y, point.z);
        if (((point.X || point.X === 0) && typeof point.X === 'number') && ((point.Y || point.Y === 0) && typeof point.Y === 'number') && ((point.Z || point.Z === 0) && typeof point.Z === 'number'))
            return gl_matrix_1.vec3.fromValues(point.X, point.Y, point.Z);
        return gl_matrix_1.vec3.create();
    }
};
Converter = __decorate([
    tsyringe_1.singleton()
], Converter);
exports.Converter = Converter;
//# sourceMappingURL=Converter.js.map